diff -urN lib/defs.h diablo-5-CUR-20060522-Fanch/lib/defs.h
--- lib/defs.h	2005-11-02 17:21:59.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/lib/defs.h	2006-06-01 18:37:58.000000000 +0200
@@ -257,7 +257,7 @@
 
 #define HMAGIC		((uint32)0xA1B2C3D4)
 #define HDEADMAGIC	((uint32)0xDEADF5E6)
-#define HVERSION	2
+#define HVERSION	3
 
 /*
  * Dreaderd cache scoreboard
@@ -320,7 +320,7 @@
     hash_t	hv;		/* hash value			*/
     uint16 	iter;		/* file id 			*/
     uint16	exp;		/* hours relative to gmt minutes */
-    uint32	boffset;	/* starting offset in file	*/
+    off_t	boffset;	/* starting offset in file	*/
     int32	bsize;		/* size of article		*/
 } History;
 
@@ -479,7 +479,7 @@
 #define MAXMSGIDLEN	250
 #define MAXGNAME	256
 #ifndef	MAXFORKS
-#define MAXFORKS	512
+#define MAXFORKS	1024
 #endif
 #ifndef	MAXFEEDS
 #define MAXFEEDS	128
@@ -518,8 +518,37 @@
 /*
  * Expire methods
  */
-#define EXM_SYNC		0
-#define EXM_DIRSIZE		1
+#define SPOOL_EXPIRE_SYNC	0x00	/* sync, default */
+#define SPOOL_EXPIRE_DIRSZ	0x01	/* dirsize */
+#define SPOOL_EXPIRE_CYCLIC	0x80	/* cyclic buffer */
+
+#define CBH_BYTEORDER		0xd1c2b3a4
+#define CBH_VERSION		0x00000002 /* :-) */
+
+#define CBH_FLG_NOACCESS	0x80000000
+#define CBH_FLG_SPOOLMASK	0x000000ff /* spool */
+
+#define CBH_MD5_BUFSIZE		512	/* the spool MD5SUM is computed on the first 512 bytes */
+#define CBH_WRAPPED		0x00000001 /* the spool has wrapped */
+
+typedef struct CyclicBufferHead {
+    int			cbh_version;
+    int			cbh_byteOrder;
+    off_t		cbh_offset;	/* space kept for file header */
+    off_t		cbh_size;	/* file size */
+    off_t		cbh_pos;	/* position inside the cyclic buffer,
+					 * starting at cbh_offset */
+    int			cbh_cycles;	/* to expire history */
+    int			cbh_flnamelen;
+    time_t		cbh_stime;	/* for stat needs */
+    off_t		cbh_spos;
+    int			cbh_scycles;
+    int			cbh_flags;
+    md5hash_t		cbh_md5;
+    /* if the buffer head is stored in a dedicated file, cbh_flnamelen will be
+     * set to the buffer filename len and this filename will be stored just
+     * after this struct */
+} CyclicBufferHead;
 
 typedef struct SpoolObject {
     uint16		so_SpoolNum;
@@ -531,7 +560,11 @@
     int			so_SpoolDirs;
     int			so_ExpireMethod;
     int			so_CompressLvl;
+    int			so_cbhHeadFD;
+    struct CyclicBufferHead *so_cbhHead;
+    int			so_cbhSpoolFD;
     char		so_Path[PATH_MAX];
+    char		so_CPth[PATH_MAX];
     struct SpoolObject	*so_Next;
 } SpoolObject;
 
diff -urN lib/history.c diablo-5-CUR-20060522-Fanch/lib/history.c
--- lib/history.c	2004-07-20 22:25:54.000000000 +0200
+++ diablo-5-CUR-20060522-Fanch/lib/history.c	2006-06-01 11:52:37.000000000 +0200
@@ -382,12 +382,12 @@
 void
 PrintHistory(History *h)
 {
-    printf(" [hv=%08x.%08x gm=%d ex=%d off=%d len=%d F=%s]\n",
+    printf(" [hv=%08x.%08x gm=%d ex=%d off=%lld len=%d F=%s]\n",
 		h->hv.h1,
 		h->hv.h2,
 		(int)h->gmt,
 		(int)h->exp,
-		(int)h->boffset,
+		(long long int)h->boffset,
 		(int)h->bsize,
 		((h->exp & EXPF_HEADONLY) ? "H" : "")
     );
diff -urN lib/lock.c diablo-5-CUR-20060522-Fanch/lib/lock.c
--- lib/lock.c	2001-08-02 11:08:54.000000000 +0200
+++ diablo-5-CUR-20060522-Fanch/lib/lock.c	2006-06-08 17:05:20.000000000 +0200
@@ -11,6 +11,7 @@
 
 Prototype int xflock(int fd, int flags);
 Prototype int hflock(int fd, off_t offset, int flags);
+Prototype int lflock(int fd, off_t offset, off_t len, int flags);
 
 /*
  * xflock() - a global lock.  
@@ -46,6 +47,12 @@
 int 
 hflock(int fd, off_t offset, int flags)
 {
+    return(lflock(fd, offset, 4, flags));
+}
+
+int 
+lflock(int fd, off_t offset, off_t len, int flags)
+{
     int r;
     struct flock fl = { 0 };
 
@@ -62,7 +69,7 @@
     }
     fl.l_whence = SEEK_SET;
     fl.l_start = offset;
-    fl.l_len = 4;
+    fl.l_len = len;
 
     r = fcntl(fd, ((flags & XLOCK_NB) ? F_SETLK : F_SETLKW), &fl);
     if (DebugOpt > 4)
diff -urN lib/spool.c diablo-5-CUR-20060522-Fanch/lib/spool.c
--- lib/spool.c	2006-05-22 14:05:41.000000000 +0200
+++ diablo-5-CUR-20060522-Fanch/lib/spool.c	2006-06-05 18:46:59.000000000 +0200
@@ -44,9 +44,16 @@
 Prototype uint16 GetSpool(const char *msgid, const char *nglist, int size, int arttype, char *label, int *t, int *complvl);
 Prototype uint32 SpoolDirTime(void);
 Prototype int AllocateSpools(time_t t);
-Prototype void LoadSpoolCtl(time_t gmt, int force);
+Prototype void LoadSpoolCtl(time_t gmt, int force, int romode);
 Prototype int GetFirstSpool(uint16 *spoolnum, char **path, double *maxsize, double *minfree, long *minfreefiles, long *keeptime, int *expmethod);
 Prototype int GetNextSpool(uint16 *spoolnum, char **path, double *maxsize, double *minfree, long *minfreefiles, long *keeptime, int *expmethod);
+Prototype SpoolObject *findSpoolObject(uint16 spool);
+Prototype off_t getCycBufPos(SpoolObject *so, int size, int *cycles, int *flags);
+Prototype int lockCycBufArt(SpoolObject *so, History *h, int *locked);
+Prototype int checkCycBufSpool(uint16 spool);
+Prototype int checkCycBufBounds(SpoolObject *so, History *h);
+Prototype int checkArticle(char *relPath, char *msgId, off_t fileOff, int fileSize, uint16 spoolNum, char *spoolOpt);
+Prototype int md5CycBuf(SpoolObject *so, md5hash_t *md5);
 
 SpoolObject *SpoolObjects = NULL;
 SpoolObject *CurrentSpoolObject = NULL;
@@ -60,7 +67,7 @@
 int createSpoolDir(SpoolObject *so, uint32 gmt);
 uint16 findSpoolGrp(const char *msgid, GroupList *groups, int size, int ngcount, int arttype, char *label, int *t, int *complvl);
 int findLabel(LabelList *ll, char *label);
-void loadSpoolCtl(FILE *fi);
+void loadSpoolCtl(FILE *fi, int romode);
 double spaceFreeOn(char *part);
 void dumpSpoolConfig(void);
 
@@ -74,22 +81,26 @@
 {
     char *spool;
 
-    spool = GetSpoolPath(H_SPOOL(h->exp), h->gmt, opt);
-
-    if (spool == NULL) {
-	strcpy(path, "/dev/null");
-	return;
-    }
-    switch (opt) {
-	case ARTFILE_DIR:
-	case ARTFILE_DIR_REL:
+    if (checkCycBufSpool(H_SPOOL(h->exp))) {
+	SpoolObject *so;
+	so = findSpoolObject(H_SPOOL(h->exp));
+	snprintf(path, pathSize, "%s", so->so_CPth);
+    } else {
+	spool = GetSpoolPath(H_SPOOL(h->exp), h->gmt, opt);
+	if (spool == NULL) {
+	    strcpy(path, "/dev/null");
+	    return;
+	}
+	switch (opt) {
+	    case ARTFILE_DIR:
+	    case ARTFILE_DIR_REL:
 		snprintf(path, pathSize, "%s%sD.%08x",
 					spool,
 					spool[0] ? "/" : "",
 					h->gmt - h->gmt % 10);
 		break;
-	case ARTFILE_FILE:
-	case ARTFILE_FILE_REL:
+	    case ARTFILE_FILE:
+	    case ARTFILE_FILE_REL:
 		if (h->boffset || h->bsize) {
 		    snprintf(path, pathSize, "%s%sD.%08x/B.%04x",
 					spool,
@@ -106,8 +117,9 @@
 					h->iter);
     		}
 		break;
-	default:
+	    default:
 		break;
+	}
     }
     if (DebugOpt > 4)
 	printf("ArticleFileName=%s\n", path);
@@ -250,6 +262,10 @@
     History h;
     struct stat st;
 	
+    if (so->so_ExpireMethod==SPOOL_EXPIRE_CYCLIC) {
+	return(0); /* no need to create spool dir in a cyclic buffer */
+    }
+
     h.gmt = gmt;
     h.exp = so->so_SpoolNum + 100;
     ArticleFileName(path, sizeof(path), &h, ARTFILE_DIR);
@@ -392,8 +408,255 @@
     return((uint16)-1);
 }
 
+SpoolObject*
+findSpoolObject(uint16 spool)
+{
+    if (spool > MAX_SPOOL_OBJECTS)
+	return(NULL);
+    if (SpoolObjectMap[spool] && SpoolObjectMap[spool]->so_SpoolNum == spool) {
+	return(SpoolObjectMap[spool]);
+    }
+    return(NULL);
+}
+
+int
+checkCycBufSpool(uint16 spool)
+{
+    SpoolObject *so;
+    
+    if (spool > MAX_SPOOL_OBJECTS)
+	return(0);
+    so = findSpoolObject(spool);
+    if (so->so_ExpireMethod==SPOOL_EXPIRE_CYCLIC) {
+	return(1);
+    }
+    return(0);
+}
+
+int
+checkCycBufBounds(SpoolObject *so, History *h)
+{
+    int cyc1, cyc2;
+    off_t pos;
+
+    cyc1=so->so_cbhHead->cbh_cycles;
+    pos=so->so_cbhHead->cbh_pos;
+    cyc2=so->so_cbhHead->cbh_cycles;
+    if (cyc1!=cyc2 || cyc1==-1) {
+	hflock(so->so_cbhHeadFD, 0, XLOCK_SH);
+	cyc1=so->so_cbhHead->cbh_cycles;
+	pos=so->so_cbhHead->cbh_pos;
+	hflock(so->so_cbhHeadFD, 0, XLOCK_UN);
+    }
+
+    if ((cyc1&0xffff)==h->iter) {
+	if (pos > h->boffset+h->bsize)
+	    return 0;
+	logit(LOG_CRIT, "cyclic spool pos corrupted (article %x.%x pos %lli cycles %i)", h->hv.h1, h->hv.h2, pos, cyc1);
+    } else if (((cyc1-1)&0xffff) == h->iter && pos < h->boffset)
+	return 0;
+    return -1;
+}
+
+int
+checkArticle(char *relPath, char *msgId, off_t fileOff, int fileSize, uint16 spoolNum, char *spoolOpt)
+{
+    if (checkCycBufSpool(spoolNum)) { /* spoolOpt should contain cycles */
+	SpoolObject *so;
+	History h;
+	
+	so = findSpoolObject(spoolNum);
+	h.iter = strtol(spoolOpt, NULL, 10) & 0xffff;
+	h.boffset = fileOff;
+	h.bsize = fileSize;
+	return checkCycBufBounds(so, &h);
+    }
+    return 0;
+}
+
+int
+lockCycBufArt(SpoolObject *so, History *h, int *locked)
+{
+    if (so->so_cbhSpoolFD<0) return -1;
+
+    if (checkCycBufBounds(so, h)) return -1;
+
+    if (lflock(so->so_cbhSpoolFD, h->boffset, h->bsize+1, XLOCK_SH|XLOCK_NB)<0) {
+logit(LOG_CRIT, "  locking cycbuf failed (fd %i %x@%llx)", so->so_cbhSpoolFD, h->bsize+1, h->boffset);
+	return -1;
+    }
+
+    if (checkCycBufBounds(so, h)) {
+logit(LOG_CRIT, "unlocking cycbuf (fd %i %x@%llx) due to bounds", so->so_cbhSpoolFD, h->bsize+1, h->boffset);
+	lflock(so->so_cbhSpoolFD, h->boffset, h->bsize+1, XLOCK_UN);
+	return -1;
+    }
+
+    *locked = so->so_cbhSpoolFD;
+    return 0;
+}
+
+off_t
+getCycBufPos(SpoolObject *so, int size, int *cycles, int *flags)
+{
+    if (so->so_cbhHead==NULL || so->so_cbhSpoolFD==-1 || so->so_cbhHeadFD==-1) {
+	return -1;
+    }
+
+    if(size) { /* écriture */
+	CyclicBufferHead *cbh = so->so_cbhHead;
+	int cyc;
+	off_t pos;
+
+	/* LOCK */
+	hflock(so->so_cbhHeadFD, 0, XLOCK_EX);
+
+	if (cbh->cbh_pos+size+1>cbh->cbh_size) { /* wrapping */
+	    if (flags) *flags |= CBH_WRAPPED;
+	    if (size<CBH_MD5_BUFSIZE) size = CBH_MD5_BUFSIZE-1;
+	    cyc = cbh->cbh_cycles;
+	    cbh->cbh_cycles = -1; /* read lock trigger */
+	    pos = cbh->cbh_offset;
+	    cbh->cbh_pos = pos+size+1;
+	    cbh->cbh_cycles = cyc+1;
+logit(LOG_CRIT, "getBufCycPos: wrap %llx+%x -> %llx (cycles %i)", pos, size, cbh->cbh_pos, cbh->cbh_cycles);
+	} else {
+	    pos = cbh->cbh_pos;
+	    cbh->cbh_pos += size+1;
+	}
+	*cycles = cbh->cbh_cycles;
+
+	/* UNLOCK */
+	hflock(so->so_cbhHeadFD, 0, XLOCK_UN);
+
+	return pos;
+    } else { /* lecture */
+	int cyc1, cyc2;
+	off_t pos;
+
+	cyc1=so->so_cbhHead->cbh_cycles;
+	pos=so->so_cbhHead->cbh_pos;
+	cyc2=so->so_cbhHead->cbh_cycles;
+	if (cyc1!=cyc2 || cyc1==-1) {
+	    hflock(so->so_cbhHeadFD, 0, XLOCK_SH);
+	    cyc1=so->so_cbhHead->cbh_cycles;
+	    pos=so->so_cbhHead->cbh_pos;
+	    hflock(so->so_cbhHeadFD, 0, XLOCK_UN);
+	}
+	*cycles = cyc1;
+	return pos;
+    }
+}
+
+/*
+ * the function checks so->so_cbhHead->cbh_md5 and return 0 if it matches
+ * if md5 is not NULL, it will store the md5 value into it
+ */
+int
+md5CycBuf(SpoolObject *so, md5hash_t *md5)
+{
+    char buf[CBH_MD5_BUFSIZE];
+    struct diablo_MD5Context ctx;
+    md5hash_t m;
+
+    if (md5==NULL) {
+	md5 = &m;
+    }
+
+    if (so->so_cbhHead->cbh_pos<512) {
+	printf("CycBuf : not enough data to process md5 on spool %s\n", so->so_Path);
+	exit(1);
+    }
+    lseek(so->so_cbhSpoolFD, so->so_cbhHead->cbh_offset, SEEK_SET);
+    read(so->so_cbhSpoolFD, buf, sizeof(buf));
+
+    diablo_MD5Init(&ctx);
+    diablo_MD5Update(&ctx, buf, sizeof(buf));
+
+    diablo_MD5Final((unsigned char *)md5, &ctx);
+    return memcmp(md5, &so->so_cbhHead->cbh_md5, sizeof(md5hash_t)); 
+}
+
+void
+openCycBuf(SpoolObject *so, char *path, char *spth, int romode)
+{
+    struct CyclicBufferHead cbh;
+    ssize_t r;
+
+    if (romode) {
+	so->so_cbhSpoolFD = open(path, O_RDONLY);
+    } else {
+	so->so_cbhSpoolFD = open(path, O_RDWR);
+    }
+    if (so->so_cbhSpoolFD==-1) {
+	logit(LOG_CRIT, "CycBuf : can not open file %s", path);
+	exit(1);
+    }
+    so->so_cbhHeadFD = so->so_cbhSpoolFD;
+    r = read(so->so_cbhSpoolFD, &cbh, sizeof(CyclicBufferHead));
+    if (r!=sizeof(CyclicBufferHead)) {
+	logit(LOG_CRIT, "CycBuf : short read %s (%i/%i)", path, r, sizeof(CyclicBufferHead));
+	if (cbh.cbh_version!=CBH_VERSION)
+		logit(LOG_CRIT, "CycBuf : wrong version, please update your buffer (%s)", path);
+	exit(1);
+    }
+    if (romode) {
+	so->so_cbhHead = xmap(NULL, sizeof(CyclicBufferHead), PROT_READ, MAP_SHARED, so->so_cbhSpoolFD, 0);
+    } else {
+	so->so_cbhHead = xmap(NULL, sizeof(CyclicBufferHead), PROT_READ|PROT_WRITE, MAP_SHARED, so->so_cbhSpoolFD, 0);
+    }
+    if (so->so_cbhHead->cbh_byteOrder!=CBH_BYTEORDER) {
+	logit(LOG_CRIT, "CycBuf : wrong byte order or file has not been initialize (%s)", path);
+	exit(1);
+    }
+    if (so->so_cbhHead->cbh_version!=CBH_VERSION) {
+	logit(LOG_CRIT, "CycBuf : wrong version, please update your buffer (%s)", path);
+	exit(1);
+    }
+
+    if (cbh.cbh_flnamelen!=0) { /* spool filename */
+
+	if (cbh.cbh_flnamelen>PATH_MAX) {
+	    logit(LOG_CRIT, "CycBuf : spool file name too long %s (%i/%i)", path, cbh.cbh_flnamelen, PATH_MAX);
+	    exit(1);
+	}
+	r = read(so->so_cbhSpoolFD, spth, cbh.cbh_flnamelen);
+	if (r!=cbh.cbh_flnamelen) {
+	    logit(LOG_CRIT, "CycBuf : short spool filename read %s (%i/%i)", path, r, cbh.cbh_flnamelen);
+	    exit(1);
+	}
+	if (romode) {
+	    so->so_cbhSpoolFD = open(spth, O_RDONLY);
+	} else {
+	    so->so_cbhSpoolFD = open(spth, O_RDWR);
+	}
+	if (so->so_cbhSpoolFD==-1) {
+	    logit(LOG_CRIT, "CycBuf : can not open spool file %s", spth);
+	    exit(1);
+	}
+    } else {
+	strncpy(spth, path, PATH_MAX);
+    }
+    if (so->so_cbhHead->cbh_flags&CBH_FLG_SPOOLMASK) {
+	if (so->so_SpoolNum != (so->so_cbhHead->cbh_flags & CBH_FLG_SPOOLMASK)) {
+	    logit(LOG_CRIT, "CycBuf : spool mismatch, %s is not spool %i (found spool %i)", path, so->so_SpoolNum, (so->so_cbhHead->cbh_flags & CBH_FLG_SPOOLMASK));
+	    exit(1);
+	}
+    	if (md5CycBuf(so, NULL)) {
+	    logit(LOG_CRIT, "CycBuf : wrong md5sum on spool %i (%s)", so->so_SpoolNum, spth);
+	    exit(1);
+	}
+    } else {
+	if (!romode) {
+	    so->so_cbhHead->cbh_flags = (so->so_cbhHead->cbh_flags & ~CBH_FLG_SPOOLMASK) | (so->so_SpoolNum & CBH_FLG_SPOOLMASK);
+	    logit(LOG_INFO, "CycBuf : affecting %s to spool %i and processing md5", path, so->so_SpoolNum);
+    	    md5CycBuf(so, &so->so_cbhHead->cbh_md5);
+	}
+    }
+}
+
 void
-addSpool(SpoolObject *so)
+addSpool(SpoolObject *so, int romode)
 {
     struct stat st;
     char *path;
@@ -401,6 +664,9 @@
 
     SpoolObjectMap[so->so_SpoolNum] = so;
     so->so_Next = NULL;
+    if (so->so_ExpireMethod==SPOOL_EXPIRE_CYCLIC) {
+	so->so_SpoolDirs = 0;
+    }
     if (!so->so_Path[0])
 	snprintf(so->so_Path, sizeof(so->so_Path), "P.%02d",
 				so->so_SpoolNum);
@@ -422,6 +688,15 @@
 	    logit(LOG_CRIT, "%s: Missing spool partition %s",
 				PatLibExpand(DSpoolCtlPat), path);
 	    exit(1);
+	} else if (so->so_ExpireMethod==SPOOL_EXPIRE_CYCLIC) {
+	    if (S_ISBLK(st.st_mode)) {
+		openCycBuf(so, path, so->so_CPth, romode);
+	    } else if (S_ISREG(st.st_mode)) {
+		openCycBuf(so, path, so->so_CPth, romode);
+	    } else {
+	    	logit(LOG_CRIT, "CycBuf : unknown type %s", path);
+		exit(1);
+	    }
 	}
     }
 
@@ -497,6 +772,7 @@
 
 uint32 SpoolGmtMin = (uint32)-1;
 time_t SpoolMTime = 0;
+int SpoolRoMode = -1;
 
 #define	EXSTAT_NONE	0x00
 #define	EXSTAT_SPOOL	0x01
@@ -505,7 +781,29 @@
 #define	EXSTAT_OVERVIEW	0x08
 
 void
-loadSpoolCtl(FILE *fi)
+cleanSpoolObjects(SpoolObject *so)
+{
+    while(so) {
+	if (so->so_ExpireMethod==SPOOL_EXPIRE_CYCLIC) {
+	    if (so->so_cbhHead) {
+		xunmap(so->so_cbhHead, sizeof(CyclicBufferHead));
+		so->so_cbhHead = NULL;
+	    }
+	    if (so->so_cbhHeadFD>-1 && so->so_cbhHeadFD!=so->so_cbhSpoolFD) {
+		close(so->so_cbhHeadFD);
+	    }
+	    so->so_cbhHeadFD = -1;
+	    if (so->so_cbhSpoolFD > -1) {
+		close(so->so_cbhSpoolFD);
+		so->so_cbhSpoolFD = -1;
+	    }
+	}
+	so = so->so_Next;
+    }
+}
+
+void
+loadSpoolCtl(FILE *fi, int romode)
 {
     char buf[MAXGNAME+256];
     int status = EXSTAT_NONE;
@@ -515,6 +813,7 @@
     MetaSpool *metaSpool = NULL;
     GroupExpire *expire = NULL;
 
+    cleanSpoolObjects(SpoolObjects);
     freePool(&SPMemPool);
     SpoolObjects = NULL;
     MetaSpools = NULL;
@@ -553,7 +852,7 @@
 	    switch (status) {
 		case EXSTAT_SPOOL:
 		     if (spoolObj->so_SpoolNum != 0)
-			addSpool(spoolObj);
+			addSpool(spoolObj, romode);
 		     spoolObj = NULL;
 		     break;
 		case EXSTAT_META:
@@ -592,6 +891,8 @@
 	    }
 	    status = EXSTAT_SPOOL;
 	    spoolObj->so_CompressLvl = -1;
+	    spoolObj->so_cbhHeadFD = -1;
+	    spoolObj->so_cbhSpoolFD = -1;
 	    continue;
 	}
 	if (!status && strcmp(cmd, "metaspool") == 0) {
@@ -650,9 +951,11 @@
 		continue;
 	    } else if (strcmp(cmd, "expiremethod") == 0) {
 		if (strcmp(arg, "sync") == 0)
-		    spoolObj->so_ExpireMethod = 0;
+		    spoolObj->so_ExpireMethod = SPOOL_EXPIRE_SYNC;
 		else if (strcmp(arg, "dirsize") == 0)
-		    spoolObj->so_ExpireMethod = 1;
+		    spoolObj->so_ExpireMethod = SPOOL_EXPIRE_DIRSZ;
+		else if (strcmp(arg, "cyclic") == 0)
+		    spoolObj->so_ExpireMethod = SPOOL_EXPIRE_CYCLIC;
 		else  {
 		    logit(LOG_ERR, "%s: Unknown expiremethod '%s' in line %d",
 				PatLibExpand(DSpoolCtlPat), arg, line);
@@ -800,13 +1103,15 @@
  * NOTE: exit program if any errors
  */
 void
-LoadSpoolCtl(time_t gmt, int force)
+LoadSpoolCtl(time_t gmt, int force, int romode)
 {
     /*
      * check for dspool.ctl file modified once a minute
      */
 
     gmt = gmt / 60;
+    if (SpoolRoMode!=romode) force = 1;
+
     if (force || gmt != SpoolGmtMin) {
 	struct stat st = { 0 };
 
@@ -833,7 +1138,7 @@
 		if (force)
 		    fstat(fileno(fi), &st);
 		SpoolMTime = st.st_mtime; /* may be 0 if file failed to open */
-		loadSpoolCtl(fi);
+		loadSpoolCtl(fi, romode);
 	    }
 	    if (fi)
 		fclose(fi);
@@ -841,6 +1146,7 @@
 		dumpSpoolConfig();
 	}
     }
+    SpoolRoMode=romode;
 }
 
 /*
diff -urN lib/vendor.h diablo-5-CUR-20060522-Fanch/lib/vendor.h
--- lib/vendor.h	2006-01-04 00:10:08.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/lib/vendor.h	2006-06-01 11:52:37.000000000 +0200
@@ -313,3 +313,9 @@
  * reducing system load.
  */
 #undef	BIG_MBUF
+ 
+/*
+ * USE_SENDFILE allow the use the sendfile syscall. Right now, it is only used to :
+ * - replying to head/body/article request on diablo
+ */
+#define USE_SENDFILE 1
diff -urN lib/xmap.c diablo-5-CUR-20060522-Fanch/lib/xmap.c
--- lib/xmap.c	2004-12-12 09:42:42.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/lib/xmap.c	2006-06-01 11:52:37.000000000 +0200
@@ -36,7 +36,7 @@
 
     st.st_size = 0;
     fstat(fd, &st);
-    if (offset + len > ((st.st_size + XPageMask) & ~XPageMask)) {
+    if (!S_ISBLK(st.st_mode) && (offset + len > ((st.st_size + XPageMask) & ~XPageMask))) {
         ptr = NULL;
 	errno = EINVAL;
     } else {
diff -urN util/XMakefile diablo-5-CUR-20060522-Fanch/util/XMakefile
--- util/XMakefile	2004-01-18 22:34:56.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/XMakefile	2006-06-05 12:57:19.000000000 +0200
@@ -7,7 +7,7 @@
 		dreadover dpath dprimehostcache dstart dclient \
 		dfeedinfo dlockhistory dfeedtest doverctl drequeue \
 		dhisbench dhisexpire dhisctl dexpirecache dcancel \
-		dexpirescoring
+		dexpirescoring dinitcycbuf dcbinfo dcycheadupdate
 .set SPROGS	diablo dnewslink dgrpctl
 .set SRCS	$(PROGS:"*":"*.c") $(SPROGS:"*":"*.c")
 .set OBJS	$(PROGS:"*":"$(BD)obj/util_*.o") $(SPROGS:"*":"$(BD)obj/util_*.o")
diff -urN util/dcancel.c diablo-5-CUR-20060522-Fanch/util/dcancel.c
--- util/dcancel.c	2004-12-22 20:59:33.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dcancel.c	2006-06-01 11:52:37.000000000 +0200
@@ -135,7 +135,7 @@
 	Usage();
     if (HistoryCancel || SpoolCancel) {
 	HistoryOpen(NULL, 0);
-	LoadSpoolCtl(0, 1);
+	LoadSpoolCtl(0, 1, 1);
     }
 
     if (inputFile == NULL)
@@ -525,7 +525,7 @@
 	}
 	if (copyArt) {
 	    h.boffset = lseek(newf, 0, 1);
-	    printf("Copying article at offset %lld to offset %d\n",
+	    printf("Copying article at offset %lld to offset %lld\n",
 							filepos, h.boffset);
 	    if (compressed) {
 		lseek(oldf, filepos, SEEK_SET);
diff -urN util/dcbinfo.c diablo-5-CUR-20060522-Fanch/util/dcbinfo.c
--- util/dcbinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dcbinfo.c	2006-06-01 11:52:37.000000000 +0200
@@ -0,0 +1,136 @@
+#include "defs.h"
+
+int resetStat = 0;
+
+void
+Usage(void)
+{
+    printf("Show stats on cyclic buffers.\n\n");
+    printf("dcbinfo [-r]\n");
+    printf("where:\n");
+    printf("\t-r\t- reset bandwidth statistics\n");
+    exit(1);
+}
+
+void
+BandwidthToString (char *buf, size_t bufsize, float bw)
+{
+    char *symb=" KMGTP";
+    int p=0;
+    
+    while(bw>1000 && p<strlen(symb)) {
+	bw = bw/1000;
+	p++;
+    }
+    snprintf(buf, bufsize, "%.2f %cbps", bw, symb[p]);
+}
+
+void
+TimeToString (char *buf, size_t bufsize, time_t tm)
+{
+    time_t days=24*3600, hours=3600, minutes=60;
+
+    if(tm>days) {
+	int d;
+	int l;
+	
+	d = (int)tm/days;
+	tm = tm%days;
+	l = snprintf(buf, bufsize, "%i days ", d);
+	buf += l;
+	bufsize -= l;
+    }
+    if(tm>hours) {
+	int d;
+	int l;
+	
+	d = (int)tm/hours;
+	tm = tm%hours;
+	l = snprintf(buf, bufsize, "%i hours ", d);
+	buf += l;
+	bufsize -= l;
+    }
+    if(tm>minutes) {
+	int d;
+	int l;
+	
+	d = (int)tm/minutes;
+	tm = tm%minutes;
+	l = snprintf(buf, bufsize, "%i minutes ", d);
+	buf += l;
+	bufsize -= l;
+    }
+    snprintf(buf, bufsize, "%i seconds", (int)tm);
+}
+
+
+int
+main(int ac, char **av)
+{
+    int i;
+    uint16 spoolnum;
+    char *path;
+    double maxsize = 0.0;
+    double minfree = 0.0;
+    long minfreefiles = 0;
+    long keeptime = 0;
+    int expmethod = SPOOL_EXPIRE_SYNC;
+    SpoolObject *so = NULL;
+
+    LoadDiabloConfig(ac, av);
+    LoadSpoolCtl(0, 1, 0);
+
+    for (i=1; i<ac; ++i) {
+	char *ptr = av[i];
+
+	if (*ptr == '-') {
+	    ptr += 2;
+	    switch(ptr[-1]) {
+	    case 'r':
+		resetStat = 1;
+		break;
+	    default:
+		Usage();
+		break;
+	    }
+	}
+    }
+
+    i = GetFirstSpool(&spoolnum, &path, &maxsize, &minfree, &minfreefiles, &keeptime, &expmethod);
+    while(i) {
+	if (expmethod&SPOOL_EXPIRE_CYCLIC) {
+	    off_t pos, size, deltapos;
+	    int retention;
+	    time_t deltatime;
+	    char buf[200];
+
+	    so = findSpoolObject(spoolnum);
+	    printf("found spool %i path %s\n", spoolnum, so->so_Path);
+
+	    pos = so->so_cbhHead->cbh_pos;
+	    size = so->so_cbhHead->cbh_size - so->so_cbhHead->cbh_offset;
+	    printf("\tposition %lli / %lli (%.2f%%) cycles %i\n", pos, size, pos*100.0/size, so->so_cbhHead->cbh_cycles);
+
+	    deltapos = pos - so->so_cbhHead->cbh_spos + (so->so_cbhHead->cbh_cycles - so->so_cbhHead->cbh_scycles) * size;
+	    deltatime = time(NULL) - so->so_cbhHead->cbh_stime;
+	    if (deltatime==0) deltatime = 1;
+	    BandwidthToString (buf, sizeof(buf), (float)deltapos*8.0/deltatime);
+	    printf("\t%lli bytes used in %i seconds (%s)\n", deltapos, (int)deltatime, buf);
+
+	    if (deltapos) {
+		retention = deltatime * size / deltapos;
+		TimeToString (buf, sizeof(buf), retention);
+		printf("\tretention should be around %s\n", buf);
+	    } else
+		printf("\tretention is unknown\n");
+
+	    if(resetStat) {
+		so->so_cbhHead->cbh_stime = time(NULL);
+		so->so_cbhHead->cbh_spos = pos;
+		so->so_cbhHead->cbh_scycles = so->so_cbhHead->cbh_cycles;
+	    }
+	}
+	i = GetNextSpool(&spoolnum, &path, &maxsize, &minfree, &minfreefiles, &keeptime, &expmethod);
+    }
+    return 0;
+}
diff -urN util/dcycheadupdate.c diablo-5-CUR-20060522-Fanch/util/dcycheadupdate.c
--- util/dcycheadupdate.c	1970-01-01 01:00:00.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dcycheadupdate.c	2006-06-08 16:33:30.000000000 +0200
@@ -0,0 +1,168 @@
+#include "defs.h"
+
+typedef struct CyclicBufferHead_v1 {
+    int                 cbh_version;
+    int                 cbh_byteOrder;
+    off_t               cbh_offset;     /* space kept for file header */
+    off_t               cbh_size;       /* file size */
+    off_t               cbh_pos;        /* position inside the cyclic buffer,
+                                         * starting at cbh_offset */
+    int                 cbh_cycles;     /* to expire history */
+    int                 cbh_flnamelen;
+    time_t              cbh_stime;      /* for stat needs */
+    off_t               cbh_spos;
+    int                 cbh_scycles;
+    /* if the buffer head is stored in a dedicated file, cbh_flnamelen will be
+     * set to the buffer filename len and this filename will be stored just
+     * after this struct */
+} CyclicBufferHead_v1;
+
+void
+Usage(void) {
+    printf("Usage : dcycheadupdate file [files...]\n");
+    printf("to update cyclic buffer headers\n");
+    exit(0);
+}
+
+int
+main(int argc, char **argv) {
+    int i;
+
+    if (argc==1) {
+	Usage();
+	exit(1);
+    }
+    for (i=1; i<argc; i++) {
+	char *opt = argv[i];
+	int r;
+
+	if (opt[0]=='-') {
+	    opt++;
+	    switch (*opt) {
+	    case 'h' :
+		Usage();
+		break;
+	    default :
+		fprintf(stderr, "unknown option: %s\n", opt - 1);
+		Usage();
+	    }
+	} else {
+	    int file;
+	    int version;
+
+	    file = open(opt, O_RDWR);
+	    r = read(file, &version, sizeof(version));
+	    if (r!=sizeof(version)) {
+		printf("Cannot read version %s\n", opt);
+		exit(1);
+	    }
+	    lseek(file, 0, SEEK_SET);
+
+	    switch(version) {
+		case 1: 
+		     {
+			struct CyclicBufferHead_v1 oldcbh;
+			struct CyclicBufferHead newcbh;
+			char spath[PATH_MAX];
+
+			r = read(file, &oldcbh, sizeof(oldcbh));
+			if (r!=sizeof(oldcbh)) {
+			    printf("Cannot read header %s\n", opt);
+			}
+			printf("*** old version was 1 ***\n\tVersion : %i\n\tByteOrder : %x\n\tOffset : %lli\n\tSize : %lli\n\tPos : %lli\n\tCycles : %i\n\tflnamelen : %i\n\tstime : %i\n\tspos : %lli\n\tscycles : %i\n", oldcbh.cbh_version, oldcbh.cbh_byteOrder, oldcbh.cbh_offset, oldcbh.cbh_size, oldcbh.cbh_pos, oldcbh.cbh_cycles, oldcbh.cbh_flnamelen, oldcbh.cbh_stime, oldcbh.cbh_spos, oldcbh.cbh_scycles);
+			if (oldcbh.cbh_byteOrder!=CBH_BYTEORDER) {
+			    printf("CycBuf : wrong byte order or file has not been initialize (%s)\n", opt);
+			    exit(1);
+			}
+			if (oldcbh.cbh_flnamelen!=0) { /* spool filename */
+			    if (oldcbh.cbh_flnamelen>PATH_MAX) {
+				printf("CycBuf : spool file name too long %s (%i/%i)\n", opt, oldcbh.cbh_flnamelen, PATH_MAX);
+				exit(1);
+			    }
+			    r = read(file, spath, oldcbh.cbh_flnamelen);
+			    if (r!=oldcbh.cbh_flnamelen) {
+				printf("CycBuf : short spool filename read %s (%i/%i)\n", opt, r, oldcbh.cbh_flnamelen);
+				exit(1);
+			    }
+			    printf("\tspool : %s\n", spath);
+			} else {
+			    if (oldcbh.cbh_offset<sizeof(newcbh)) {
+				printf("CycBuf : can not update %s headers, data offset is too low to store updated headers\n", opt);
+			    }
+			}
+
+			newcbh.cbh_version = CBH_VERSION;
+			newcbh.cbh_byteOrder = CBH_BYTEORDER;
+			
+			newcbh.cbh_offset = oldcbh.cbh_offset;
+			newcbh.cbh_size = oldcbh.cbh_size;
+			newcbh.cbh_pos = oldcbh.cbh_pos;
+			newcbh.cbh_cycles = oldcbh.cbh_cycles;
+			newcbh.cbh_flnamelen = oldcbh.cbh_flnamelen;
+			newcbh.cbh_stime = oldcbh.cbh_stime;
+			newcbh.cbh_spos = oldcbh.cbh_spos;
+			newcbh.cbh_scycles = oldcbh.cbh_scycles;
+
+			newcbh.cbh_flags = 0;
+
+			/* md5 hash */
+			{
+			    SpoolObject so;
+
+			    so.so_cbhHead = &newcbh;
+			    strcpy(so.so_Path, opt);
+			    if (oldcbh.cbh_flnamelen) {
+				so.so_cbhSpoolFD = open(spath, O_RDONLY);
+			    } else {
+				so.so_cbhSpoolFD = file;
+			    }
+
+			    md5CycBuf(&so, &newcbh.cbh_md5);
+
+			    if (oldcbh.cbh_flnamelen) close(so.so_cbhSpoolFD);
+			}
+			printf("*** new version ***\n\tVersion : %i\n\tByteOrder : %x\n\tOffset : %lli\n\tSize : %lli\n\tPos : %lli\n\tCycles : %i\n\tflnamelen : %i\n\tstime : %i\n\tspos : %lli\n\tscycles : %i\n\tFlags : %i\n\tmd5 : %llx%llx\n", newcbh.cbh_version, newcbh.cbh_byteOrder, newcbh.cbh_offset, newcbh.cbh_size, newcbh.cbh_pos, newcbh.cbh_cycles, newcbh.cbh_flnamelen, newcbh.cbh_stime, newcbh.cbh_spos, newcbh.cbh_scycles, newcbh.cbh_flags, newcbh.cbh_md5.h1, newcbh.cbh_md5.h2);
+			lseek(file, 0, SEEK_SET);
+			{
+			    int i;
+			    i = write(file, &newcbh, sizeof(newcbh));
+			    printf("write returned %i (%i)\n", i, errno);
+			}
+			if (oldcbh.cbh_flnamelen) {
+			    write(file, spath, oldcbh.cbh_flnamelen);
+			}
+		     }
+		     break;
+		case CBH_VERSION: /* nothing to do... */
+		     {
+			struct CyclicBufferHead cbh;
+			char spath[PATH_MAX];
+
+			r = read(file, &cbh, sizeof(cbh));
+			if (r!=sizeof(cbh)) {
+			    printf("Cannot read header %s\n", opt);
+			}
+			printf("*** Version : %i\n\tByteOrder : %x\n\tOffset : %lli\n\tSize : %lli\n\tPos : %lli\n\tCycles : %i\n\tflnamelen : %i\n\tstime : %i\n\tspos : %lli\n\tscycles : %i\n\tflags : %i\n\tmd5 : %llx%llx\n", cbh.cbh_version, cbh.cbh_byteOrder, cbh.cbh_offset, cbh.cbh_size, cbh.cbh_pos, cbh.cbh_cycles, cbh.cbh_flnamelen, cbh.cbh_stime, cbh.cbh_spos, cbh.cbh_scycles, cbh.cbh_flags, cbh.cbh_md5.h1, cbh.cbh_md5.h2);
+			if (cbh.cbh_flnamelen!=0) { /* spool filename */
+			    if (cbh.cbh_flnamelen>PATH_MAX) {
+				printf("CycBuf : spool file name too long %s (%i/%i)\n", opt, cbh.cbh_flnamelen, PATH_MAX);
+				exit(1);
+			    }
+			    r = read(file, spath, cbh.cbh_flnamelen);
+			    if (r!=cbh.cbh_flnamelen) {
+				printf("CycBuf : short spool filename read %s (%i/%i)\n", opt, r, cbh.cbh_flnamelen);
+				exit(1);
+			    }
+			    printf("\tspool : %s\n", spath);
+			}
+		     }
+		     break;
+		default:
+		     printf("unknown version %i in %s header\n", version, opt);
+		     exit(1);
+	    }
+	    close(file);
+	}
+    }
+    return 0;
+}
diff -urN util/dexpire.c diablo-5-CUR-20060522-Fanch/util/dexpire.c
--- util/dexpire.c	2004-09-20 00:04:22.000000000 +0200
+++ diablo-5-CUR-20060522-Fanch/util/dexpire.c	2006-06-08 16:37:57.000000000 +0200
@@ -333,7 +333,7 @@
     SpoolEntries = malloc(entryMax * sizeof(SpoolEnt *));
     entryIdx = 0;
      
-    LoadSpoolCtl(0, 1);
+    LoadSpoolCtl(0, 1, 1);
 
     /*
      * Open and get a copy of the history file size before we scan the spools
@@ -375,12 +375,17 @@
 	double minfree = 0.0;
 	long minfreefiles = 0;
 	long keeptime = 0;
-	int expmethod = EXM_SYNC;
+	int expmethod = SPOOL_EXPIRE_SYNC;
 	
 	for (i = GetFirstSpool(&spoolnum, &path, &maxsize, &minfree, &minfreefiles, &keeptime, &expmethod); i;
 		i = GetNextSpool(&spoolnum, &path, &maxsize, &minfree, &minfreefiles, &keeptime, &expmethod))  {
 	    if (SinglePart && *SinglePart != spoolnum)
 		continue;
+	    if (expmethod==SPOOL_EXPIRE_CYCLIC) {
+		if (VerboseOpt)
+		    printf("Spool Object: %02d (cyclic buffer, no expire)\n", spoolnum);
+		continue;
+	    }
 	    {
 		Partition *p = (Partition *)malloc(sizeof(Partition));;
 	
@@ -396,17 +401,17 @@
 		p->minfreefiles = minfreefiles;
 		p->maxsize = maxsize;
 		p->keeptime = keeptime;
+		p->spaceok = 0;
 		if (UseDirSize)
-		    p->expmethod = EXM_DIRSIZE;
+		    p->expmethod = SPOOL_EXPIRE_DIRSZ;
 		else
 		    p->expmethod = expmethod;
-		p->spaceok = 0;
 		p->filesys = findFileSys(p->partname);
-		p->next = Partitions;
-		Partitions = p;
 		if (FreeSpaceTargetList[spoolnum] > 0.0)
 		    p->minfree = FreeSpaceTargetList[spoolnum];
 		scanDirectory(p);
+		p->next = Partitions;
+		Partitions = p;
 	    }
 	}
     }
@@ -633,6 +638,8 @@
 	part = SpoolEntries[i]->partn;
 	if (part->spaceok)
 	    continue;
+	if (part->filesys==NULL)
+	    continue;
 
 	spacefree = part->filesys->fsfree;
 	freefiles = part->filesys->fsfreefiles;
@@ -660,7 +667,7 @@
 	    if (part->minfreefiles)
 		printf("\tfreefiles=%ld/%ld\n", freefiles, part->minfreefiles);
 	    printf("\texpire method %s",
-			(part->expmethod == EXM_SYNC) ? "sync" : "dirsize");
+			(part->expmethod == SPOOL_EXPIRE_SYNC) ? "sync" : "dirsize");
 
 	}
 	if (part->minfree && spacefree < part->minfree)
@@ -705,7 +712,7 @@
 	    UpdateHistory = 1;
 	part->filesys->fsfree += remsize;
 	part->filesys->fsfreefiles += c;
-	if (part->expmethod == EXM_DIRSIZE || part->maxsize) {
+	if (part->expmethod == SPOOL_EXPIRE_DIRSZ || part->maxsize) {
 	    SpoolEntries[i]->dirsize = remsize;
 	    part->partsize -= remsize;
 	} else if (!NotForReal && (part->minfree || part->minfreefiles))
@@ -714,7 +721,7 @@
 	if (i + 1 < entryIdx)
 	    part->age = TimeNow - getAge(SpoolEntries[i + 1]->dirname);
 	if (VerboseOpt) {
-	    if (part->expmethod == EXM_DIRSIZE || part->maxsize)
+	    if (part->expmethod == SPOOL_EXPIRE_DIRSZ || part->maxsize)
 		printf("     Removed %s (used: %s free: %s age: %s)\n",
 					ftos(remsize),
 					ftos(part->partsize),
@@ -788,6 +795,11 @@
     if (DebugOpt > 1)
 	printf("Scanning directory: %s\n", scanpart->partname);
 
+    if (scanpart->expmethod==SPOOL_EXPIRE_CYCLIC) {
+	if (DebugOpt > 1)
+	    printf("\tcyclic buffer\n");
+	return;
+    }
     if ((dir = opendir(scanpart->partname)) == NULL) {
 	fprintf(stderr, "Unable to scan directory: %s (%s)\n",
 				scanpart->partname, strerror(errno));
@@ -850,7 +862,7 @@
 		SpoolEntries[entryIdx]->dirsize = 0.0;
 		SpoolEntries[entryIdx]->dirname = strdup(den->d_name);
 
-		if (scanpart->expmethod == EXM_DIRSIZE || scanpart->maxsize) {
+		if (scanpart->expmethod == SPOOL_EXPIRE_DIRSZ || scanpart->maxsize) {
 		    SpoolEntries[entryIdx]->dirsize =
 				findSize(scanpart->partname, den->d_name);
 		    scanpart->partsize += SpoolEntries[entryIdx]->dirsize;
@@ -969,6 +981,8 @@
 
 	if (SpoolEntries[i]->removed)
 	    continue;
+	if (SpoolEntries[i]->partn->filesys==NULL)
+	    continue;
 
 	partnameLen = strlen(SpoolEntries[i]->partn->partname);
 
@@ -1067,7 +1081,7 @@
 		h = &hist[i];
 		path[0] = 0;
 
-		if (TestOpt) {
+		if (TestOpt && !checkCycBufSpool(H_SPOOL(h->exp))) {
 		    int res;
 
 		    ArticleFileName(path, sizeof(path), h, ARTFILE_DIR_REL);
@@ -1113,35 +1127,52 @@
 		if (h->hv.h1 == 0 && h->hv.h2 == 0)
 		    continue;
 
-		if (!UnexpireOpt)
-		    ArticleFileName(path, sizeof(path), h, ARTFILE_DIR_REL);
+		{
+		    int updated=0;
 
-		if (UnexpireOpt || findNode(path, 0) < 0) {
-		    if (!UnexpireOpt && VerboseOpt > 1) {
-			printf("Unable to find path %s (%08x.%08x), %s history record\n",
-			    path,
-			    h->hv.h1, h->hv.h2,
-			    ((HistoryUpdateOpt != 2) ? "expiring" : "would expire")
-			);
+		    if (UnexpireOpt) {
+			updated = 1;
+			h->exp &= ~EXPF_EXPIRED;
+		    } else if(checkCycBufSpool(H_SPOOL(h->exp))) {
+			if (checkCycBufBounds(findSpoolObject(H_SPOOL(h->exp)), h)) {
+			    if (VerboseOpt > 1) {
+				printf("Cyclic buffer %i overwriten (%08x.%08x), %s history record\n",
+				    H_SPOOL(h->exp), h->hv.h1, h->hv.h2,
+				    ((HistoryUpdateOpt != 2) ? "expiring" : "would expire")
+				);
+			    }
+			    if (HistoryUpdateOpt != 2) {
+				updated = 1;
+				h->exp |= EXPF_EXPIRED;
+			    }
+			}
+		    } else {
+			ArticleFileName(path, sizeof(path), h, ARTFILE_DIR_REL);
+
+			if (findNode(path, 0) < 0) {
+			    if (VerboseOpt > 1) {
+				printf("Unable to find path %s (%08x.%08x), %s history record\n",
+				    path, h->hv.h1, h->hv.h2,
+				    ((HistoryUpdateOpt != 2) ? "expiring" : "would expire")
+				);
+			    }
+			    if (HistoryUpdateOpt != 2) {
+				updated = 1;
+				h->exp |= EXPF_EXPIRED;
+			    }
+			}
 		    }
-		    if (UnexpireOpt || HistoryUpdateOpt != 2) {
+		    if (updated) {
+			++countExp;
 			changed = 1;
-			if (UnexpireOpt)
-			    h->exp &= ~EXPF_EXPIRED;
-			else
-			    h->exp |= EXPF_EXPIRED;
-			lseek(
-			    HistoryFd,
-			    bpos + sizeof(History) * i + offsetof(History, exp),
-			    0
-			);
+
+			lseek(HistoryFd, bpos + sizeof(History) * i + offsetof(History, exp), 0);
 			if (!NotForReal)
 			    write(HistoryFd, &h->exp, sizeof(h->exp));
 
 			if (WriteHashesToFileOpt == 1)
 			    fwrite(&h->hv, sizeof(hash_t), 1, DExpOverList);
 		    }
-		    ++countExp;
 		}
 	    }
 	    if (changed)
diff -urN util/dfeedtest.c diablo-5-CUR-20060522-Fanch/util/dfeedtest.c
--- util/dfeedtest.c	2004-02-14 22:53:50.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dfeedtest.c	2006-06-01 11:52:37.000000000 +0200
@@ -207,7 +207,7 @@
 	printf("\tSpam: %s\n", Spam ? "Yes" : "No");
 	if (SpoolMatch) {
 	    uint16 Spool;
-	    LoadSpoolCtl(0, 1);
+	    LoadSpoolCtl(0, 1, 1);
 	    AllocateSpools(0);
 	    Spool = GetSpool(MessageId, Newsgroups, atoi(Size),
                         ArtType, Label, NULL, NULL);
diff -urN util/dhisctl.c diablo-5-CUR-20060522-Fanch/util/dhisctl.c
--- util/dhisctl.c	2003-01-15 23:19:29.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dhisctl.c	2006-06-01 11:52:37.000000000 +0200
@@ -24,6 +24,7 @@
 int ForReal = 1;
 int StructSizes = 0;
 int HistoryHead = 0;
+int HistoryInfo = 0;
 
 void DumpHeader(int fd);
 void DoEntry(char *msgid);
@@ -45,6 +46,7 @@
     printf("\t-e\t- expire the article(s)\n");
     printf("\t-f\t- file containing list of msgid's or '-' for stdin\n");
     printf("\t-h\t- display history header and total size details\n");
+    printf("\t-i\t- display history entry informations\n");
     printf("\t-p\t- show progress on stdout\n");
     printf("\t-S\t- display sizes of internal history structures and exit\n");
     printf("\t-u\t- unexpire the article(s)\n");
@@ -102,6 +104,9 @@
 	case 'h':
 	    HistoryHead = 1;
 	    break;
+	case 'i':
+	    HistoryInfo = 1;
+	    break;
 	case 'p':
 	    ShowProgress = 1;
 	    break;
@@ -246,6 +251,15 @@
 	fprintf(stderr, "History lookup failed for %s\n", msgid);
 	return;
     }
+    if (HistoryInfo) {
+	printf("Article %s :\n", msgid);
+	printf("\thash : %x.%x\n", hv.h1, hv.h2);
+	printf("\tinfo : ");
+	if (h.exp & EXPF_HEADONLY) printf("header-only ");
+	if (h.exp & EXPF_EXPIRED) printf("expired");
+	printf("(%i)\n", h.exp);
+	printf("\tspool %i offset %lli size %i iter %i\n", H_SPOOL(h.exp), h.boffset, h.bsize, h.iter);
+    }
     if (FixEntry(&h, msgid) && ForReal)
 	HistoryStoreExp(&h, (HistIndex)pos);
 }
diff -urN util/diablo.c diablo-5-CUR-20060522-Fanch/util/diablo.c
--- util/diablo.c	2005-10-16 17:07:07.000000000 +0200
+++ diablo-5-CUR-20060522-Fanch/util/diablo.c	2006-06-05 12:54:22.000000000 +0200
@@ -36,6 +36,10 @@
 #include <sys/termios.h>
 #endif
 
+#if USE_SENDFILE
+#include <sys/sendfile.h>
+#endif
+
 typedef struct Feed {
     struct Feed *fe_Next;
     char	*fe_Label;
@@ -60,6 +64,21 @@
     char	addr[64];
 } Track;
 
+#define OpArtReg 0x0000;
+#define OpArtCyc 0x0001;
+
+struct OpArt {
+    int type;
+    char *data;
+    int fd;
+    int fdtoclose;
+    off_t offset;
+    int fsize;
+    int headOnly;
+    int compressed;
+    int pmart;
+} OpArt;
+
 #define RET_CLOSE	1
 #define RET_PAUSE	2
 #define RET_LOCK	3
@@ -79,12 +98,12 @@
 void DoListNotify(FILE *fo, char *l);
 void DoStats(FILE *fo, int dt, int raw);
 int LoadArticle(Buffer *bi, const char *msgid, int noWrite, int headerOnly, char *refBuf, char *artType);
-int SendArticle(const char *data, int fsize, FILE *fo, int doHead, int doBody);
+int SendArticle(struct OpArt *opa, int fd, FILE *fo, int doHead, int doBody);
 void ArticleFileInit(void);
 #ifdef USE_ZLIB
-int ArticleFile(History *h, off_t *pbpos, int clvl, gzFile **cfile);
+int ArticleFile(History *h, off_t *pbpos, int clvl, gzFile **cfile, int *cycles, int *flags);
 #else
-int ArticleFile(History *h, off_t *pbpos, int clvl, char **cfile);
+int ArticleFile(History *h, off_t *pbpos, int clvl, char **cfile, int *cycles, int *flags);
 #endif
 void ArticleFileCloseAll(void);
 void ArticleFileCacheFlush(time_t t);
@@ -106,7 +125,9 @@
 void FinishRetain(int what);
 int QueueRange(const char *label, int *pqnum, int *pqarts, int *pqrun);
 int countFds(fd_set *rfds);
-int ArticleOpen(History *h, const char *msgid, char **pfi, int32 *rsize, int *pmart, int *pheadOnly, int *compressed);
+int ArticleOpen(struct OpArt *opa, History *h, const char *msgid, int *locked, int dobody);
+void ArticleClose (struct OpArt *opa);
+void ArticleCheckFlag(History *h, int flag);
 
 void DoArtStats(int statgroup, int which, int bytes);
 void DoSpoolStats(int which);
@@ -155,7 +176,7 @@
 hash_t	PeerIpHash;
 int	HasStatusLine = 0;
 MemPool	*ParProcMemPool;
-int	ReadOnlyCxn = 0;		/* Read-only client connection */
+int	ReadOnlyCxn = -1;		/* RO by default but dspool.ctl will be reloaded */
 int	ReadOnlyMode = 0;		/* Server switched to RO mode */
 pid_t	HostCachePid = 0;
 time_t	SpoolAllocTime = 0;
@@ -858,7 +879,7 @@
      * a label.
      */
 
-    LoadSpoolCtl(0, 1);		/* check spool partitions if specified */ 
+    LoadSpoolCtl(0, 1, ReadOnlyCxn);		/* check spool partitions if specified */ 
     LoadNewsFeed(0, 1, NULL);
 
     {
@@ -890,7 +911,7 @@
 
 	t = time(NULL);
 
-	LoadSpoolCtl(t, 0);	/* check spool partitions if specified */ 
+	LoadSpoolCtl(t, 0, ReadOnlyCxn);	/* check spool partitions if specified */ 
 	LoadNewsFeed(t, 0, NULL);
 	if (HostCachePid == 0)
 	    HostCachePid = LoadHostAccess(t, 0, DOpts.HostCacheRebuildTime);
@@ -1631,10 +1652,13 @@
     }
 
     LoadNewsFeed(0, 1, HLabel);	/* free old memory and load only our label */
+    ReadOnlyCxn = FeedReadOnly(HLabel);
+				/* force read-only?			   */
+    LoadSpoolCtl(time(NULL), 0, ReadOnlyCxn);	/* check spool partitions if specified */ 
 
     ConfigNewsFeedSockOpts(HLabel, nfd, fd);
 
-    if (ReadOnlyMode && !FeedReadOnly(HLabel)) {
+    if (ReadOnlyMode && !ReadOnlyCxn) {
 	xfprintf(fo, "502 %s DIABLO is currently in read-only mode\r\n",
 		DOpts.FeederHostName);
 	fflush(fo);
@@ -1673,8 +1697,6 @@
     }
 
     ArticleFileInit();		/* initialize article file cache	   */
-    ReadOnlyCxn = FeedReadOnly(HLabel);
-				/* force read-only?			   */
 
     if ((DOpts.FeederActiveEnabled && (DOpts.FeederXRefSync || DOpts.FeederXRefSlave == 0)) || DOpts.FeederActiveDrop)
 	InitDActive(ServerDActivePat); /* initialize dactive.kp if enabled   */
@@ -1993,7 +2015,7 @@
 		    ArticleFileName(path, sizeof(path), &h, ARTFILE_FILE_REL);
 		else
 		    ArticleFileName(path, sizeof(path), &h, ARTFILE_FILE);
-		xfprintf(fo, "223 0 whereis %s in %s offset %i length %i\r\n", msgid, path, h.boffset, h.bsize) ;
+		xfprintf(fo, "223 0 whereis %s in %s offset %lli length %i\r\n", msgid, path, h.boffset, h.bsize) ;
 	    } else {
 		if (H_EXPIRED(h.exp) && h.iter != (unsigned short)-1) {
 		    xfprintf(fo, "430 Article expired\r\n");
@@ -2021,25 +2043,26 @@
 		   strcasecmp(cmd, "article") == 0
 	) {
 	    const char *msgid = MsgId(strtok(NULL, "\r\n"), NULL);
-	    char *data = NULL;
-	    int32 fsize = 0;
-	    int pmart = 0;
-	    int headOnly = 0;
-	    int compressed = 0;
 	    History h;
+	    int doHead = 0;
+	    int doBody = 0;
 	    enum ArtState { AS_ARTICLE, AS_BODY, AS_HEAD } as = AS_HEAD;
 
 	    switch(cmd[0]) {
 	    case 'b':
 	    case 'B':
 		as = AS_BODY;
+		doBody=1;
 		break;
 	    case 'a':
 	    case 'A':
 		as = AS_ARTICLE;
+		doBody = 1;
+		doHead = 1;
 		break;
 	    default:	/* default, must be AS_HEAD */
 		as = AS_HEAD;
+		doHead = 1;
 		break;
 	    }
 	    h.exp = 0;
@@ -2057,9 +2080,11 @@
 		    break;
 		}
 	    } else if (HistoryLookup(msgid, &h) == 0 && !H_EXPIRED(h.exp)) {
-		if (ArticleOpen(&h, msgid, &data, &fsize, &pmart, &headOnly, &compressed) != 0)
-		    data = NULL;
-		if (data && headOnly && as != AS_HEAD) {
+		int locked=-1;
+	    	struct OpArt opa;
+		if (ArticleOpen(&opa, &h, msgid, &locked, doBody) != 0)
+		    opa.data = NULL;
+		if (opa.data && opa.headOnly && as != AS_HEAD) {
 		    xfprintf(fo, "430 Article not found\r\n");
 		    switch(as) {
 		    case AS_BODY:
@@ -2074,9 +2099,7 @@
 		    }
 		    if (DebugOpt > 2)
 			ddprintf(">> (NO DATA: BODY/ARTICLE REQUEST FOR HEADER-ONLY STORE)");
-		} else if (data) {
-		    int doHead = 0;
-		    int doBody = 0;
+		} else if (opa.data) {
 		    int bytes;
 
 #ifdef	STATS_ART_AGE
@@ -2086,31 +2109,22 @@
 		    switch(as) {
 		    case AS_BODY:
 			xfprintf(fo, "222 0 body %s\r\n", msgid);
-			doBody = 1;
 			DoSpoolStats(STATS_S_BODY);
 			break;
 		    case AS_ARTICLE:
 			xfprintf(fo, "220 0 article %s\r\n", msgid);
-			doHead = 1;
-			doBody = 1;
 			DoSpoolStats(STATS_S_ARTICLE);
 			break;
 		    default:
-			doHead = 1;
 			xfprintf(fo, "221 0 head %s\r\n", msgid);
 			DoSpoolStats(STATS_S_HEAD);
 			break;
 		    }
-		    if (doBody && !compressed) {
-			if (DOpts.SpoolPreloadArt)
-			    xadvise(data, fsize, XADV_WILLNEED);
-			xadvise(data, fsize, XADV_SEQUENTIAL);
-		    }
 
 		    if (DebugOpt > 2)
 			ddprintf(">> (DATA)");
 
-		    bytes = SendArticle(data, fsize, fo, doHead, doBody);
+		    bytes = SendArticle(&opa, fd, fo, doHead, doBody);
 
 		    Stats.SpoolStats.ArtsBytesSent += (double)bytes;
 		    if (HostStats != NULL) {
@@ -2134,6 +2148,11 @@
 		    if (DebugOpt > 2)
 			ddprintf(">> (NO DATA: UNABLE TO FIND ARTICLE)");
 		}
+
+		if (locked>=0) {
+		    lflock(locked, h.boffset, h.bsize+1, XLOCK_UN);
+		}
+		ArticleClose(&opa);
 	    } else {
 		if (H_EXPIRED(h.exp) && h.iter != (unsigned short)-1) {
 		    xfprintf(fo, "430 Article expired\r\n");
@@ -2163,12 +2182,6 @@
 		    }
 		}
 	    }
-	    if (data) {
-		if (compressed)
-		    free(data);
-		else
-		    xunmap(data, fsize + pmart);
-	    }
 	} else if (strcasecmp(cmd, "stat") == 0) {
 	    const char *msgid = MsgId(strtok(NULL, "\r\n"), NULL);
 	    History h;
@@ -2409,13 +2422,15 @@
  * Send a mmap'ed article to a FILE, doing conversion if necessary
  */
 int
-SendArticle(const char *data, int fsize, FILE *fo, int doHead, int doBody)
+SendArticle(struct OpArt *opa, int fd, FILE *fo, int doHead, int doBody)
 {
     int b;
     int i;
     int inHeader = 1;
     int bytes = 0;
     SpoolArtHdr ah;
+    char* data = opa->data;
+    int fsize = opa->fsize;
 
     bcopy(data, &ah, sizeof(ah));
 
@@ -2436,16 +2451,38 @@
 	    }
 	}
 	if (ah.StoreType & STORETYPE_WIRE) {
+	    int b=0;
+#if USE_SENDFILE
+	    off_t offset;
+
+	    offset = opa->offset + (unsigned int)data - (unsigned int)opa->data;
+
+	    fflush(fo);
+	    b = sendfile(fd, opa->fd, &offset, fsize);
+	    while(b!=-1 && b!=fsize) {
+		fsize -= b;
+		data += b;
+		b = sendfile(fd, opa->fd, &offset, fsize);
+	    }
+	    
+	    if (b==-1) {
+		if ((errno==EINVAL)||(errno=ENOSYS)) {
+		    b = fwrite(data, fsize, 1, fo);
+		} else {
+		    logit(LOG_ERR, "sendfile failed with errno=%i (%s)", errno, strerror(errno));
+		}
+	    }
+#else
+	    b = fwrite(data, fsize, 1, fo);
+#endif
 	    if (doBody) {
-		return(fwrite(data, fsize, 1, fo));
+		return(b);
 	    } else {
-		int b;
-		b = fwrite(data, fsize, 1, fo);
 		xfprintf(fo, ".\r\n");
 		return(b + 3);
 	    }
 	}
-    } else if (*data == 0) {
+    } else if (data == 0) {
 	data++;
     }
 
@@ -2608,6 +2644,7 @@
 	int bps;
 	int aflen = 0;
 	int headerLen = 0;
+	int cycles = -1;
 
 	struct timespec delay;
 	int delay_counter = 0;
@@ -3231,10 +3268,14 @@
 	 * is set to a zero size on the spool, effectively deleting it
 	 */
 
+/*
+logit(LOG_CRIT, "LoadArticle3 : mid %s comp %i sat %i", msgid, CompressLvl, SpoolAllocTime);*/
+AllocateSpools(SpoolAllocTime); /* grmpf, something has to be fixed */
 	if (retcode == RCOK && !artError && buffer != NULL) {
 	    int interval = 0;
 	    char z = 0;
 	    uint16 spool = 0;
+	    int locksize = 0;
 
 	    h.exp = 0;
 	    spool = GetSpool(msgid, nglist, size, arttype, HLabel, &interval, &CompressLvl);
@@ -3252,6 +3293,7 @@
 	    }
 	    h.gmt = SpoolDirTime();
 	    if (spool <= 100) {
+		int flag=0;
 #ifdef USE_ZLIB
 		gzFile *cfile = NULL;
 #else
@@ -3259,9 +3301,8 @@
 #endif
 		h.exp = spool + 100;
 		h.bsize = bsize(buffer) + sizeof(artHdr);
-		artFd = ArticleFile(&h, &bpos, CompressLvl, &cfile);
+		artFd = ArticleFile(&h, &bpos, CompressLvl, &cfile, &cycles, &flag);
 		if (artFd >= 0) {
-		    h.bsize = bsize(buffer) + sizeof(artHdr);
 		    artHdr.Magic1 = STORE_MAGIC1;
 		    artHdr.Magic2 = STORE_MAGIC2;
 		    artHdr.Version = STOREAPI_REVISION;
@@ -3273,6 +3314,11 @@
 		    artHdr.ArtHdrLen = headerLen;
 		    artHdr.ArtLen = bsize(buffer);
 		    artHdr.StoreLen = h.bsize + 1;
+		    if(cycles!=-1) {
+			/* the data is locked after increasing buffer pos */
+			locksize = h.bsize+1;
+			lflock(artFd, bpos, locksize, XLOCK_EX);
+		    }
 		    write(artFd, &artHdr, sizeof(artHdr));
 		    bsetfd(buffer, artFd);
 #ifdef USE_ZLIB
@@ -3289,6 +3335,9 @@
 		} else {
 		    artError |= LAERR_IO;
 		}
+	    if (flag) {
+		ArticleCheckFlag(&h, flag);
+	    }
 	    } else {
 		/*
 		 * This means we don't have metaspool object for this
@@ -3304,7 +3353,7 @@
 	    /*
 	     * Write out the article
 	     */
-	    h.boffset = (uint32)bpos;
+	    h.boffset = bpos;
 #ifdef USE_ZLIB
 	    if (CompressLvl >= 0 && CompressLvl <= 9) {
 		off_t filePos;
@@ -3320,10 +3369,11 @@
 #endif
 	    bwrite(buffer, &z, 1);		/* terminator (sanity check) */
 	    bflush(buffer);
+	    if(locksize) lflock(artFd, bpos, locksize, XLOCK_UN);
 	    if (DebugOpt > 1)
-		ddprintf("%s: b=%08lx artFd=%d boff=%d bsize=%d",
+		ddprintf("%s: b=%08lx artFd=%d boff=%lld bsize=%d",
 			msgid, (long)buffer, artFd,
-			(int)h.boffset, (int)h.bsize
+			(long long int)h.boffset, (int)h.bsize
 		);
 	}
 
@@ -3628,10 +3678,10 @@
 	 * If we created a file but the return code is
 	 * not RCOK, truncate the file.
 	 */
-	if (artFd >= 0)
+	if (artFd >= 0 && cycles == -1)
 	    ArticleFileSetSize(artFd);
 
-	if (retcode != RCOK && artFd >= 0) {
+	if (retcode != RCOK && artFd >= 0 && cycles == -1) {
 	    ArticleFileTrunc(artFd, bpos);
 	}
     }
@@ -4349,13 +4399,27 @@
 
 int
 #ifdef USE_ZLIB
-ArticleFile(History *h, off_t *pbpos, int clvl, gzFile **cfile)
+ArticleFile(History *h, off_t *pbpos, int clvl, gzFile **cfile, int *cycles, int *flags)
 #else
-ArticleFile(History *h, off_t *pbpos, int clvl, char **cfile)
+ArticleFile(History *h, off_t *pbpos, int clvl, char **cfile, int *cycles, int *flags)
 #endif
 {
     AFCache	*af = NULL;
     int		rfd = -1;
+    SpoolObject	*so = NULL;
+
+    /* Look for cyclic buffer */
+    so = findSpoolObject(H_SPOOL(h->exp));
+    if (so && so->so_ExpireMethod==SPOOL_EXPIRE_CYCLIC) { 
+	off_t pos;
+	
+	pos = getCycBufPos(so, h->bsize, cycles, flags);
+	*pbpos = pos;
+	h->iter = *cycles & 0xffff;
+	if(pos>=0 && pos==lseek(so->so_cbhSpoolFD, pos, SEEK_SET)) {
+	    return so->so_cbhSpoolFD;
+	}
+    }
 
     /*
      * Look for entry in cache.
@@ -4583,33 +4647,44 @@
 }
 
 int
-MapArticle(int fd, char *fname, char **base, History *h, int *extra, int *artSize, int *compressedFormat)
+MapArticle(struct OpArt *opa, char *fname, History *h, int dobody)
 {
-    SpoolArtHdr tah = { 0 };
+    SpoolArtHdr tah;
+    char *tmpbase;
+
+    /* Any way, we mmap the file to avoid a disk seek */
+    tmpbase = xmap(NULL, h->bsize + 1, PROT_READ, MAP_SHARED, opa->fd, h->boffset);
+    if (tmpbase==NULL) {
+        logit(LOG_ERR, "Unable to mmap article header (%s)\n",
+							strerror(errno));
+	return(-1);
+    }
+
+    /* preloading now */
+    if (dobody) {
+	if (DOpts.SpoolPreloadArt) {
+	    xadvise(tmpbase, h->bsize + 1, XADV_WILLNEED);
+	} else {
+	    xadvise(tmpbase, h->bsize + 1, XADV_SEQUENTIAL);
+	}
+    }
 
     /* 
      * Fetch the spool header for the article, this tells us how it was
      * stored 
      */
+    bcopy(tmpbase, &tah, sizeof(tah));
 
-    lseek(fd, h->boffset, 0);
-    if (read(fd, &tah, sizeof(SpoolArtHdr)) != sizeof(SpoolArtHdr)) {
-        close(fd);
-        logit(LOG_ERR, "Unable to read article header (%s)\n",
-							strerror(errno));
-        return(-1);
-    }
-
-    *compressedFormat = (tah.StoreType & STORETYPE_GZIP) ? 1 : 0;
+    opa->compressed = (tah.StoreType & STORETYPE_GZIP) ? 1 : 0;
 
-    if (*compressedFormat) {
+    if (opa->compressed) {
 #ifdef USE_ZLIB
 	gzFile *gzf;
 	char *p;
 
 	if ((uint8)tah.Magic1 != STORE_MAGIC1 &&
 					(uint8)tah.Magic2 != STORE_MAGIC2) {
-	    lseek(fd, h->boffset, 0);
+	    lseek(opa->fd, h->boffset, 0);
 	    tah.Magic1 = STORE_MAGIC1;
 	    tah.Magic2 = STORE_MAGIC2;
 	    tah.HeadLen = sizeof(tah);
@@ -4618,135 +4693,150 @@
 	    tah.StoreLen = h->bsize;
 	    tah.StoreType = STORETYPE_GZIP;
 	}
-	gzf = gzdopen(dup(fd), "r");
+	/* as we have mmaped the article, we should use inflate instead of
+	 * gzdopen/gzread */
+	gzf = gzdopen(dup(opa->fd), "r");
 	if (gzf == NULL) {
 	    logit(LOG_ERR, "Error opening compressed article\n");
+	    xunmap(tmpbase, h->bsize+1);
 	    return(-1);
 	}
-    	*base = (char *)malloc(tah.ArtLen + tah.HeadLen + 2);
-	if (*base == NULL) {
+    	opa->data = (char *)malloc(tah.ArtLen + tah.HeadLen + 2);
+	if (opa->data == NULL) {
 	    logit(LOG_CRIT, "Unable to malloc %d bytes for article (%s)\n",
 				tah.ArtLen + tah.HeadLen + 2, strerror(errno));
 	    gzclose(gzf);
+	    xunmap(tmpbase, h->bsize+1);
 	    return(-1);
 	}
-	p = *base;
+	p = opa->data;
 	bcopy(&tah, p, tah.HeadLen);
 	p += tah.HeadLen;
 	if (gzread(gzf, p, tah.ArtLen) != tah.ArtLen) {
 	    logit(LOG_ERR, "Error uncompressing article\n");
-	    free(*base);
+	    free(opa->data);
+	    opa->data=NULL;
+	    xunmap(tmpbase, h->bsize+1);
 	    return(-1);
 	}
 	
 	p[tah.ArtLen] = 0;
-	*artSize = tah.ArtLen + tah.HeadLen;
-	*compressedFormat = 1;
+	opa->fsize = tah.ArtLen + tah.HeadLen;
+	opa->compressed = 1;
 	gzclose(gzf);
 #else
         logit(LOG_ERR, "Article was stored compressed and compression support has not been enabled\n");
 #endif
+	xunmap(tmpbase, h->bsize+1);
     } else {
-	    *base = xmap(
-		NULL, 
-		h->bsize + 1, 
-		PROT_READ,
-		MAP_SHARED, 
-		fd, 
-		h->boffset
-	    );
-	    *artSize = h->bsize;
+	    opa->data = tmpbase;
+	    opa->fsize = h->bsize;
+	    opa->offset = h->boffset;
     }
 
-    if (*base == NULL) {
-	logit(LOG_ERR, "Unable to map file %s: %s (%d,%d,%d)\n",
-					fname,
-					strerror(errno),
-					(int)(h->boffset - *extra),
-					 (int)(h->bsize + *extra + 1),
-					*extra
-	);
-	*artSize = 0;
-	return(-1);
-    }
     return(0);
 }
 
 int
-ArticleOpen(History *h, const char *msgid, char **pfi, int32 *rsize, int *pmart, int *pheadOnly, int *compressed)
+ArticleOpen(struct OpArt *opa, History *h, const char *msgid, int *locked, int dobody)
 {
+    char path[PATH_MAX];
     int r = -1;
-    int z = 0;
+    SpoolObject *so = NULL;
 
-    if (pheadOnly)
-	*pheadOnly = (int)(h->exp & EXPF_HEADONLY);
+    opa->type = OpArtReg;
+    opa->data = NULL;
+    opa->fd = -1;
+    opa->fdtoclose = -1;
+    opa->fsize = 0;
+    opa->pmart = 1;
 
-    if (compressed != NULL) {
-	if (SpoolCompressed(H_SPOOL(h->exp)))
-	    *compressed = 1;
-	else
-	    *compressed = 0;
-    } else {
-	compressed = &z;
-    }
+    opa->headOnly = (int)(h->exp & EXPF_HEADONLY);
+
+    if (SpoolCompressed(H_SPOOL(h->exp)))
+	opa->compressed = 1;
+    else
+	opa->compressed = 0;
 	
-    if (pfi) {
-	char path[PATH_MAX];
-	int fd;
+    /*
+     * multi-article file ?  If so, articles are zero-terminated
+     */
 
+    /* Look for cyclic buffer */
+    so = findSpoolObject(H_SPOOL(h->exp));
+    if (so && so->so_ExpireMethod==SPOOL_EXPIRE_CYCLIC && so->so_cbhSpoolFD !=-1) {
+	opa->type = OpArtCyc;
+	opa->fd = so->so_cbhSpoolFD;
+	if (opa->fd >= 0) {
+	    if (lockCycBufArt(so, h, locked)==0) {
+		r = MapArticle(opa, path, h, dobody);
+	    }
+	}
+    } else {
 	ArticleFileName(path, sizeof(path), h, ARTFILE_FILE);
 
 	/*
-	 * multi-article file ?  If so, articles are zero-terminated
+	 * get the file
 	 */
-
-	*pfi = NULL;
-	*rsize = 0;
-	*pmart = 1;
-
+	opa->fd = cdopen(path, O_RDONLY, 0);
+	opa->fdtoclose = opa->fd;
+	if (opa->fd >= 0) {
+	    r = MapArticle(opa, path, h, dobody);
+	}
+    }
+    if (r!=-1) {
 	/*
-	 * get the file
+	 * Sanity check.  Look for 0x00 guard character, make sure
+	 * first char isn't 0x00, and make sure last char isn't 0x00
+	 * (the last character actually must be an LF or the NNTP
+	 * protocol wouldn't have worked).
 	 */
-	if ((fd = cdopen(path, O_RDONLY, 0)) >= 0) {
-	    r = MapArticle(fd, path, pfi, h, pmart, rsize, compressed);
-
-	    /*
-	     * Sanity check.  Look for 0x00 guard character, make sure
-	     * first char isn't 0x00, and make sure last char isn't 0x00
-	     * (the last character actually must be an LF or the NNTP
-	     * protocol wouldn't have worked).
-	     */
-	    if (*pfi == NULL ||
-			h->bsize == 0 ||
-			(*pfi)[0] == 0 ||
-			(*pfi)[*rsize-1] == 0 ||
-			(*pfi)[*rsize] != 0
-	    ) {
-		logit(LOG_ERR, "corrupt spool entry for %s@%d,%d %s",
+	if (opa->data == NULL || h->bsize == 0 ||
+		opa->data[0] == 0 || opa->data[opa->fsize-1] == 0
+		|| opa->data[opa->fsize] != 0
+	) {
+	    logit(LOG_ERR, "corrupt spool entry for %s@%lli,%d %s",
 		    path,
-		    (int)h->boffset,
+		    (long long int)h->boffset,
 		    (int)h->bsize,
 		    msgid
-		);
-		if (*pfi) {
-		    if (*compressed)
-			free(*pfi);
-		    else
-			xunmap(*pfi, *rsize);
-		    *pfi = NULL;
-		}
-	    } 
-		
+	    );
+	    if (opa->data==NULL) {
+		logit(LOG_ERR, "data is NULL");
+	    } else {
+		logit(LOG_ERR, "data %i data0 %i data1 %i data2 %i",
+		    opa->data, opa->data[0], opa->data[opa->fsize-1], opa->data[opa->fsize]);
+	    }
+	    if (opa->data) {
+		if (opa->compressed)
+		    free(opa->data);
+		else
+		    xunmap(opa->data, opa->fsize);
+		opa->data = NULL;
+	    }
 	}
-	if (fd != -1)
-	    close(fd);
     }
-   if (pfi && *pfi)
+   if (opa->data)
 	r = 0;
     return(r);
 }
 
 void
+ArticleClose (struct OpArt *opa) {
+    if (opa->data) {
+	if (opa->compressed)
+	    free(opa->data);
+	else
+	    xunmap(opa->data, opa->fsize + opa->pmart);
+	opa->data = NULL;
+    }
+    if (opa->fdtoclose != -1) {
+	close(opa->fdtoclose);
+	opa->fdtoclose = -1;
+    }
+}
+
+void
 DoArtStats(int statgroup, int which, int bytes)	{
     ++Stats.RecStats.Stats[statgroup];
     ++Stats.RecStats.Stats[which];
@@ -4790,3 +4880,15 @@
     }
 }
 
+void
+ArticleCheckFlag(History *h, int flag)
+{
+    SpoolObject *so = NULL;
+
+    so = findSpoolObject(H_SPOOL(h->exp));
+
+    if (flag&CBH_WRAPPED) {
+	md5CycBuf(so, &so->so_cbhHead->cbh_md5);	/* MD5 update */
+    }
+}
+
diff -urN util/didump.c diablo-5-CUR-20060522-Fanch/util/didump.c
--- util/didump.c	2003-01-28 20:20:34.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/didump.c	2006-06-01 11:52:37.000000000 +0200
@@ -201,7 +201,7 @@
 	HistoryOpen(fileName, HGF_READONLY);
 
     if (VerboseOpt)
-	LoadSpoolCtl(0, 1);
+	LoadSpoolCtl(0, 1, 1);
 
 
     if (OldOpt) {
diff -urN util/diload.c diablo-5-CUR-20060522-Fanch/util/diload.c
--- util/diload.c	2001-11-21 19:40:01.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/diload.c	2006-06-01 11:52:37.000000000 +0200
@@ -148,7 +148,7 @@
 	    break;
 	}
 
-	n = sscanf(buf, "DUMP %x.%x.%x gm=%d ex=%d boff=%d bsize=%d flags=%c",
+	n = sscanf(buf, "DUMP %x.%x.%x gm=%d ex=%d boff=%lld bsize=%d flags=%c",
 	    &h.hv.h1,
 	    &h.hv.h2,
 	    &iter,
diff -urN util/diloadfromspool.c diablo-5-CUR-20060522-Fanch/util/diloadfromspool.c
--- util/diloadfromspool.c	2004-03-11 00:58:34.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/diloadfromspool.c	2006-06-08 16:04:10.000000000 +0200
@@ -20,8 +20,10 @@
  *    for specific rights granted.
  */
 
+#define _GNU_SOURCE
 #include "defs.h"
 
+
 int VerboseOpt;
 int QuietOpt;
 int LoadDupCount;
@@ -42,11 +44,12 @@
 void ScanSpool(uint16 spoolobj);
 void ScanSpoolDirectory(char *dpath, int gmt, uint16 spoolobj);
 void ScanSpoolFile(char *fpath, int gmt, int iter, uint16 spoolobj);
-void ScanSpoolFileMap(const char *base, int bytes, int gmt, int iter, char *dpath, uint16 spoolobj, int fd);
-void ScanSpoolFileMapOld(const char *base, int bytes, int gmt, int iter, char *dpath, uint16 spoolobj);
+void ScanSpoolFileMap(const char *base, off_t offset, off_t bytes, int gmt, int iter, char *dpath, uint16 spoolobj, int fd);
+void ScanSpoolFileMapOld(const char *base, off_t bytes, int gmt, int iter, char *dpath, uint16 spoolobj);
 void DoArticle(History *h, const char *id, char *nglist, char *dist,
 		char *npath, int headOnly, char *artType, char *cSize);
 int strSort(const void *s1, const void *s2);
+void ScanCycSpool(uint16 spoolnum);
 
 void
 Usage(void)
@@ -234,7 +237,7 @@
 	}
     }
 
-    LoadSpoolCtl(0, 1);
+    LoadSpoolCtl(0, 1, 1);
 
     if (RequeueOpt) {
 	ForReal = 0;
@@ -313,45 +316,148 @@
     for (i = GetFirstSpool(&spoolnum, &path, NULL, NULL, NULL, NULL, NULL); i;
 		i = GetNextSpool(&spoolnum, &path, NULL, NULL, NULL, NULL, NULL))  {
 	if (spoolobj == (uint16)-1 || spoolobj == spoolnum) {
-
-	    if (path == NULL || !*path)
-		continue;
-	    if (chdir(PatExpand(SpoolHomePat)) == -1 || chdir(path) == -1) {
-		fprintf(stderr, "Unable to chdir(%s/%s): %s\n",
+	    if (checkCycBufSpool(spoolnum)) {
+		ScanCycSpool(spoolnum);
+	    } else {
+		if (path == NULL || !*path)
+		    continue;
+		if (chdir(PatExpand(SpoolHomePat)) == -1 || chdir(path) == -1) {
+		    fprintf(stderr, "Unable to chdir(%s/%s): %s\n",
 				PatExpand(SpoolHomePat), path, strerror(errno));
-		exit(1);
-	    }
-
-	    ScanSpool(spoolnum);
-
-	    /*
-	     * Sort directories
-	     */
-	    if (FileIdx > 1)
-		qsort(FileAry, FileIdx, sizeof(char *), strSort);
+		    exit(1);
+		}
 
-	    /*
-	     * Process directories
-	     */
-	    {
-		int i;
+		ScanSpool(spoolnum);
 
-		for (i = 0; i < FileIdx; ++i) {
-		    int gmt;
-		    char *p;
+		/*
+		 * Sort directories
+		 */
+		if (FileIdx > 1)
+		    qsort(FileAry, FileIdx, sizeof(char *), strSort);
+
+		/*
+		 * Process directories
+		*/
+		{
+		    int i;
+
+		    for (i = 0; i < FileIdx; ++i) {
+			int gmt;
+			char *p;
 	
-		    p = strstr(FileAry[i], "D.");
-		    if (p && sscanf(p, "D.%x", &gmt) == 1) {
-			ScanSpoolDirectory(FileAry[i], gmt, spoolnum);
+			p = strstr(FileAry[i], "D.");
+			if (p && sscanf(p, "D.%x", &gmt) == 1) {
+			    ScanSpoolDirectory(FileAry[i], gmt, spoolnum);
+			}
 		    }
 		}
+		FileIdx = 0;
+	    }
+	}
+    }
+}
+
+void
+ScanCycSpoolPartial(SpoolObject *so, off_t pos, off_t end, uint32 gmt, uint16 cycle, off_t ref)
+{
+    char needle[] = { 0x00, STORE_MAGIC1, STORE_MAGIC2, STOREAPI_REVISION, sizeof(SpoolArtHdr) };
+    int bufsize=100*1024*1024;
+
+    while (pos < end) {
+	int size = bufsize+sizeof(SpoolArtHdr)+1;
+	int left, articles, corrupt;
+	char *ptr, *base, *start;
+	off_t startoff;
+
+	if (pos+size > so->so_cbhHead->cbh_size) size = so->so_cbhHead->cbh_size - pos;
+	base = ptr = xmap(NULL, size, PROT_READ, MAP_SHARED, so->so_cbhSpoolFD, pos);
+	xadvise(base, size, XADV_SEQUENTIAL);
+
+	/* as there should not be any \0 on spool excepted between articles, the
+	 * following search should work */
+	left = size;
+	if (pos==so->so_cbhHead->cbh_offset && memcmp(base, needle+1, sizeof(needle)-1)==0) {
+	    ptr = base-1;
+	} else {
+	    ptr = memmem(base, left, needle, sizeof(needle));
+	}
+	if (!ptr) {
+	    pos += bufsize;
+	    continue;
+	} else if (ptr!=base) {
+	    pos += ptr-base;
+	    left -= ptr-base;
+	}
+	start = ptr; startoff = pos;
+	articles = 0;
+	corrupt=0;
+	while(ptr && pos<end) {
+	    SpoolArtHdr *ah = ptr+1;
+	    int incr;
+	    char *t;
+
+	    if (ah->StoreLen > left) {
+		break;
+	    }
+	    if (*(ptr+ah->StoreLen)==0) {
+		articles++;
+		incr = ah->StoreLen;
+	    } else {
+		printf("corruption detected, seeking again\n");
+		printf("offset %llx length %x at %llx found %x", pos, ah->StoreLen, pos+ah->StoreLen, *(ptr+ah->StoreLen));
+		corrupt=1;
+		break;
+	    }
+	    pos += incr;
+	    left -= incr;
+	    /* I should not have to do this but we will be immune to sector/page
+	     * padding */
+	    ptr += incr;
+	    t = memmem(ptr, left, needle, sizeof(needle));
+	    if (ptr!=t) {
+		break;
 	    }
-	    FileIdx = 0;
 	}
+	if (VerboseOpt>1)
+	    printf("%i articles were found\nScanSpoolFileMap base %x offset %lli size %i\n", articles, start+1, startoff+1, ptr-start);
+	if (articles)
+	    ScanSpoolFileMap(start+1, startoff+1, ptr-start, gmt, cycle, so->so_Path, so->so_SpoolNum, so->so_cbhSpoolFD);
+	if (!QuietOpt) {
+	    float prc;
+	    off_t spoolsize = so->so_cbhHead->cbh_size - so->so_cbhHead->cbh_offset;
+	    if (startoff>ref) {
+		prc = (pos-ref)*100.0/spoolsize;
+	    } else {
+		prc = (pos-so->so_cbhHead->cbh_offset+spoolsize-ref)*100.0/spoolsize;
+	    }
+	    printf(" (spool %02i done %6.2f%)\n", so->so_SpoolNum, prc);
+	}
+	if (corrupt) {
+	    pos += sizeof(needle); 
+	    left -= sizeof(needle);
+	}
+	xunmap(base, size);
     }
 }
 
 void
+ScanCycSpool(uint16 spoolnum)
+{
+    SpoolObject *so;
+    off_t pos;
+    int cycle;
+    uint32 gmt = time(NULL)/60;
+
+    so = findSpoolObject(spoolnum);
+    pos = getCycBufPos(so, 0, &cycle, NULL);
+    if (!QuietOpt)
+	printf("spool %i is cyclic (file %s) pos %lli cycles %i\n", spoolnum, so->so_CPth, pos, cycle);
+   if (cycle>0)
+	ScanCycSpoolPartial(so, pos, so->so_cbhHead->cbh_size, gmt, (cycle-1)&0xffff, pos);
+    ScanCycSpoolPartial(so, so->so_cbhHead->cbh_offset, pos, gmt, cycle&0xffff, pos);
+}
+
+void
 ScanSpool(uint16 spoolobj)
 {
     DIR *dir;
@@ -417,7 +523,7 @@
 {
     int fd;
     char *base;
-    int bytes;
+    off_t bytes;
     struct stat st;
 
     if (VerboseOpt)
@@ -447,7 +553,7 @@
 
     if (bytes > 2 && (uint8)*base == (uint8)STORE_MAGIC1 &&
 				(uint8)*(base + 1) == (uint8)STORE_MAGIC2)
-	ScanSpoolFileMap(base, bytes, gmt, iter, fpath, spoolobj, fd);
+	ScanSpoolFileMap(base, 0, bytes, gmt, iter, fpath, spoolobj, fd);
     else
 	ScanSpoolFileMapOld(base, bytes, gmt, iter, fpath, spoolobj);
 
@@ -458,10 +564,10 @@
 }
 
 void
-ScanSpoolFileMap(const char *base, int bytes, int gmt, int iter, char *dpath, uint16 spoolobj, int fd)
+ScanSpoolFileMap(const char *base, off_t offset, off_t bytes, int gmt, int iter, char *dpath, uint16 spoolobj, int fd)
 {
     int count = 0;
-    int b = 0;
+    off_t b = 0;
     int arthdrlen;
     char *artbase = NULL;
     char *artpos;
@@ -486,7 +592,7 @@
 
 	    artbase = (char *)malloc(ah.ArtLen + 2);
 	    bzero(artbase, ah.ArtLen + 2);
-	    lseek(fd, b + ah.HeadLen, 0);
+	    lseek(fd, offset + b + ah.HeadLen, 0);
 	    if ((gzf = gzdopen(dup(fd), "r")) != NULL) {
 		if (gzread(gzf, artbase, len) != len)
 		    arthdrlen = 0;
@@ -531,7 +637,7 @@
 	    h.iter = iter;
 	    h.gmt = gmt;
 	    h.exp = 100 + spoolobj;
-	    h.boffset = b;
+	    h.boffset = offset+b;
 	    h.bsize = ah.StoreLen - 1;
 	    headOnly = 0;
 	    if (ah.ArtHdrLen == ah.ArtLen) {
@@ -560,9 +666,9 @@
 }
 
 void
-ScanSpoolFileMapOld(const char *base, int bytes, int gmt, int iter, char *dpath, uint16 spoolobj)
+ScanSpoolFileMapOld(const char *base, off_t bytes, int gmt, int iter, char *dpath, uint16 spoolobj)
 {
-    int b = 0;
+    off_t b = 0;
     int count = 0;
 
     /*
@@ -679,7 +785,7 @@
 	}
     }
     if (VerboseOpt > 1 || (VerboseOpt && r != 0))
-	printf("\tMessage %d,%d %s %s\n", h->boffset, h->bsize,
+	printf("\tMessage %lld,%d %s %s\n", h->boffset, h->bsize,
 				((r == 0) ? "dup" : "add"), id);
 }
 
diff -urN util/dilookup.c diablo-5-CUR-20060522-Fanch/util/dilookup.c
--- util/dilookup.c	2001-11-17 14:32:44.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dilookup.c	2006-06-01 11:52:37.000000000 +0200
@@ -78,7 +78,7 @@
 	Usage();
 
     HistoryOpen(NULL, HGF_READONLY);
-    LoadSpoolCtl(0, 1);
+    LoadSpoolCtl(0, 1, 1);
 
     if (ScanOpt == 0) {
 	r += DILookup(id);
@@ -188,7 +188,7 @@
 
 	if (h.boffset || h.bsize) {
 	    ArticleFileName(buf, sizeof(buf), &h, ARTFILE_FILE_REL);
-	    printf(" [%s hv=%08x.%08x spool=%02x gm=%d ex=%d off=%d len=%d f=%s]"
+	    printf(" [%s hv=%08x.%08x spool=%02x gm=%d ex=%d off=%lld len=%d f=%s]"
 		   " GM=(%s) EX=(%s)\n",
 		buf,
 		h.hv.h1,
@@ -196,7 +196,7 @@
 		(int)H_SPOOL(h.exp),
 		(int)h.gmt,
 		(int)h.exp,
-		(int)h.boffset,
+		(long long int)h.boffset,
 		(int)h.bsize,
 		((h.exp & EXPF_HEADONLY) ? "H" : ""),
 		tbuf1,
diff -urN util/dinitcycbuf.c diablo-5-CUR-20060522-Fanch/util/dinitcycbuf.c
--- util/dinitcycbuf.c	1970-01-01 01:00:00.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dinitcycbuf.c	2006-06-01 19:07:08.000000000 +0200
@@ -0,0 +1,179 @@
+/*
+ * dinitcycbuf.c	- init a spool cyclic buffer
+ *
+ * (c)Copyright 2005, Francois Petillon, All Rights Reserved.  Refer to
+ *    the COPYRIGHT file in the base directory of this distribution 
+ *    for specific rights granted.
+ *
+ */
+
+#include "defs.h"
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifdef __linux__
+#include <linux/fs.h> /* I should not include this but include files here are
+buggy and there is no other way to get a fucking BLKGETSIZE64 */
+#endif
+
+void
+Usage(void)
+{
+    fprintf(stderr, "Usage: dinitcycbuf [ -h headerfile ] [ -o offset ] [ -s size ] file|blockdevice\n\n");
+    fprintf(stderr, "\t-h headerfile\tthe buffer header will be store in a dedicated file\n");
+    fprintf(stderr, "\t-o offset\tsetting an offset where the data will be written\n");
+    fprintf(stderr, "\t-s size\tsetting the file/device size\n");
+    fprintf(stderr, "\n");
+    fprintf(stderr, "dinitcycbuf is used to initialize a cyclic buffer, making it usable as a spool\n");
+    fprintf(stderr, "object by diablo. An header will be written at the start of the file.\n");
+    fprintf(stderr, "You may set an offset to tell diablo where it should start to write spool data.\n");
+    fprintf(stderr, "To avoid size guessing, you also may set the file/device size (useful if the\n");
+    fprintf(stderr, "guess fails :-).\n");
+    exit(1);
+}
+
+off_t getsize(char *file)
+{
+    struct stat st;
+
+    if (stat(file, &st) != 0) {
+	fprintf(stderr, "can not stat file %s\n", file);
+	exit(1);
+    }
+
+    if (S_ISBLK(st.st_mode)) {
+	int fd;
+	off_t numblocks=0;
+
+	fd = open(file, O_RDONLY);
+	if (fd==-1) {
+    	    fprintf(stderr, "can not open block device %s\n", file);
+	    exit(1);
+	}
+#ifdef __FreeBSD__
+	ioctl(fd, DIOCGMEDIASIZE, &numblocks);
+#else /* FreeBSD */
+#if defined(__linux__) && _FILE_OFFSET_BITS == 64
+	ioctl(fd, BLKGETSIZE64, &numblocks);
+#else
+	ioctl(fd, BLKGETSIZE, &numblocks);
+	numblocks *= 512
+#endif /* Linux */
+#endif /* FreeBSD */
+	close(fd);
+
+	fprintf(stderr, "CycBuf : block device found %s (%lli bytes)\n", file, numblocks);
+
+	return(numblocks);
+    } else if (S_ISREG(st.st_mode)) {
+	fprintf(stderr, "CycBuf : regular file found %s (%lli bytes)\n", file, st.st_size);
+	return(st.st_size);
+    } else {
+	fprintf(stderr, "CycBuf : unknown type %s\n", file);
+	exit(1);
+    }
+
+}
+
+void
+headwrite(struct CyclicBufferHead *cbh, char *file, char *header)
+{
+    int fd;
+
+    if (header) {
+	fd = open(header, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP);
+    } else {
+	fd = open(file, O_WRONLY, S_IRUSR|S_IWUSR|S_IRGRP);
+    }
+    if (fd==-1) {
+	fprintf(stderr, "can not open file to write header\n");
+	exit(1);
+    }
+    write(fd, cbh, sizeof(CyclicBufferHead));
+    if(header) {
+    	write(fd, file, strlen(file)+1);
+    }
+}
+
+int
+main(int ac, char **av)
+{
+    char *file=NULL,*header=NULL;
+    int i; 
+    off_t size=0, offset=0;
+    struct CyclicBufferHead *cbh;
+
+    for (i = 1; i < ac; ++i) {
+	char *ptr = av[i];
+
+	if (*ptr != '-') {
+	    if (file) {
+		fprintf(stderr, "file/device specified twice (%s/%s)\n", file, ptr);
+		exit(1);
+	    }
+	    file = ptr;
+	    continue;
+	}
+	ptr += 2;
+	switch(ptr[-1]) {
+	case 'h':
+	    header = av[++i];
+	    break;
+	case 'o':
+	    offset = strtoll(((*ptr) ? ptr : av[++i]), NULL, 0);
+	    break;
+	case 's':
+	    size = strtoll(((*ptr) ? ptr : av[++i]), NULL, 0);
+	    break;
+	default:
+	    Usage();
+	}
+    }
+
+    if (!file) Usage();
+    if(header && !strcmp(file,header)) {
+    	header = NULL;
+    }
+    if (!header && offset<sizeof(CyclicBufferHead)) {
+	offset = (sizeof(CyclicBufferHead)/512+1)*512;
+    }
+
+    if (!size) {
+	size = getsize(file);
+    }
+
+    if (header) {
+	fprintf(stdout, "init cyclic buffer %s (header : %s, size : %lli, offset : %lli)\n", file, header, size, offset);
+    } else {
+	fprintf(stdout, "init cyclic buffer %s (size : %lli, offset : %lli)\n", file, size, offset);
+    }
+
+    cbh = (struct CyclicBufferHead*) malloc(sizeof(CyclicBufferHead));
+    cbh->cbh_version = CBH_VERSION;
+    cbh->cbh_byteOrder = CBH_BYTEORDER;
+    cbh->cbh_offset = offset;
+    cbh->cbh_size = size;
+    cbh->cbh_pos = offset+CBH_MD5_BUFSIZE; /* to keep md5 */
+    cbh->cbh_cycles = 0;
+    cbh->cbh_stime = time(NULL);
+    cbh->cbh_spos = offset;
+    cbh->cbh_scycles = 0;
+    cbh->cbh_flags = 0; /* flags & md5 will be set at first use */
+    if (header) {
+	cbh->cbh_flnamelen = strlen(file)+1;
+    } else {
+        cbh->cbh_flnamelen = 0;
+    }
+
+    headwrite(cbh, file, header);
+
+    if (header) {
+	fprintf(stdout, "%s has to be used as the entry in dspool.ctl, %s is an anonymous raw device\n", header, file);
+    }
+    exit(0);
+}
+
+
+
+
diff -urN util/doutq.c diablo-5-CUR-20060522-Fanch/util/doutq.c
--- util/doutq.c	2001-01-16 00:04:44.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/doutq.c	2006-06-01 11:52:37.000000000 +0200
@@ -123,7 +123,7 @@
 	printf("%-10s bad sequencing: %s\n", name, path);
 	return;
     }
-    printf("%-10s %5d-%-5d (%3d/%3d files %3d%% full)\t",
+    printf("%-18s %6d-%-6d (%3d/%3d files %3d%% full)\t",
 	name,
 	b,
 	e,
diff -urN util/dreadart.c diablo-5-CUR-20060522-Fanch/util/dreadart.c
--- util/dreadart.c	2003-01-25 23:01:38.000000000 +0100
+++ diablo-5-CUR-20060522-Fanch/util/dreadart.c	2006-06-01 11:52:37.000000000 +0200
@@ -105,7 +105,7 @@
 	Usage(av[0]);
 
     HistoryOpen(NULL, HGF_READONLY);
-    LoadSpoolCtl(0, 1);
+    LoadSpoolCtl(0, 1, 1);
 
     if (arg == NULL) {
 	char buf[8192];
@@ -119,7 +119,7 @@
 
 		if (strncmp(buf, "DUMP ", 5) == 0) {
 		    History h = { 0 };
-		    if (sscanf(buf + 5, "%s gm=%d ex=%hd boff=%d bsize=%d",
+		    if (sscanf(buf + 5, "%s gm=%d ex=%hd boff=%lld bsize=%d",
 					msgid, &h.gmt, &h.exp,
 					&h.boffset, &h.bsize) == 5) {
 			char *p;
@@ -175,7 +175,7 @@
 		sprintf(p, "%s/", PatExpand(SpoolHomePat));
 		p += strlen(p);
 	    }
-	    if (sscanf(arg, "%[^:]:%d,%d", p, &h.boffset, &h.bsize) == 3) {
+	    if (sscanf(arg, "%[^:]:%lld,%d", p, &h.boffset, &h.bsize) == 3) {
 		DumpArticle(fname, &h, NULL);
 	    } else {
 		printf("Unknown argument: %s\n", arg);
